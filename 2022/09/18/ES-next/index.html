<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ES-next使用说明 | 木子、佳</title><meta name="keywords" content="ES6,ES-next"><meta name="author" content="木子、佳"><meta name="copyright" content="木子、佳"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ES-next使用说明">
<meta property="og:type" content="article">
<meta property="og:title" content="ES-next使用说明">
<meta property="og:url" content="https://blog.lovelee.cn/2022/09/18/ES-next/index.html">
<meta property="og:site_name" content="木子、佳">
<meta property="og:description" content="ES-next使用说明">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.gejiba.com/images/81f26ca2da3fc4f02ed4bfed1371414e.md.png">
<meta property="article:published_time" content="2022-09-18T07:21:50.352Z">
<meta property="article:modified_time" content="2022-09-18T07:21:50.352Z">
<meta property="article:author" content="木子、佳">
<meta property="article:tag" content="ES6">
<meta property="article:tag" content="ES-next">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.gejiba.com/images/81f26ca2da3fc4f02ed4bfed1371414e.md.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.lovelee.cn/2022/09/18/ES-next/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":220},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ES-next使用说明',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-18 07:21:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="/css/extend.css">

<link rel="stylesheet" href="/css/leeblog.css">

<link rel="stylesheet" href="/css/media.css">

<link rel="stylesheet" href="https://at.alicdn.com/t/c/font_3594396_jhv1z5ewf4.css">
<style  data-label="posts_swiper" >.pix_diapo {
	background: #000;
	-moz-box-shadow: 0 3px 6px #000;
	-webkit-box-shadow: 0 3px 6px #000;
	box-shadow: 0 3px 6px #000;
	height: 470px;
	margin: 0 10px;
	overflow: hidden;
	position: relative;
	width: 940px;
}
.pix_diapo > div {
	display: none;
	height: 100%;
	left: 0;
	position: absolute;
	top: 0;
	width: 100%;
}
#pix_prev, #pix_next {
	cursor: pointer;
	display: block;
	height: 40px;
	margin-top: -20px;
	position: absolute;
	top: 50%;
	width: 40px;
	z-index: 1001;
}
#pix_prev {
	/* background: url(images/diapo/prev.png) no-repeat; */
	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoBAMAAAB+0KVeAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAnUExURQAAAAAAAHZ2ALOzAPT0AD8/AAAAAAAAAKSkAMHBABYWANvbAP//AKP9VgMAAAAMdFJOU7Ot0OL6wa6o3ue48WbZlBgAAACdSURBVCjPjdOxDcJADEBRk0gUVFClpaTIBqSlZwRWYI8UGSGzIMobKpXtb9kKXPn0dYocn7wv6QzyknSOcs54+I2nCu9rxr4tGafvM2HfHvlODYkWEi0Eegj00BGhI0JDhoYMFUOoODNUHNs1Y9c+xeRDqhhS+3imhkx9IEgdkWLIngI95Y+zlGhpWAZNA3bV2sjt7/3cx/IhVE9mA5vXK2/RhZ1AAAAAAElFTkSuQmCC) no-repeat;
	left: 10px;
}
#pix_next {
	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoBAMAAAB+0KVeAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAnUExURQAAAAAAAHZ2ALOzAD8/APT0AAAAAAAAAKSkAMHBABYWANvbAP//AEZr8lYAAAAMdFJOU7Ot0OLB+q6o3ue48RQaKpsAAACdSURBVCjPjdOxDYAgEIVhNMREK61sGcDCJdyCwhVcwUncwQ20sWAoG7h7l7sYKb/8IUAOtw1qjW51ajWu11h94mFgdxrYplmjj7ex5wIpIaZ8JEgZIYXDcwrIKV6TUkRKxYOUVGBJ5dPlVKKPj8Y6XRqnFBTmUGIOBZZQYAkRKUSkEJBDQA4ZIWSEkBBDGJtgTMj+ez5/oPkRrC/zAnnjK36knGe7AAAAAElFTkSuQmCC) no-repeat;
	left: auto!important;
	right: 10px!important;
}
#pix_pag {
	margin: 0 auto;
	position: relative;
	width: 940px;
	z-index: 1002;
}
#pix_commands {
	cursor: pointer;
	display: block;
	float: left;
	height: 26px;
	margin: 15px 0 0 13px;
	position: relative;
	width: 24px;
}
#pix_play {
	background: url(images/diapo/play.png) center no-repeat;
	height: 24px;
	left: 0;
	position: absolute;
	top: 0;
	width: 24px;
}
#pix_stop {
	background: url(images/diapo/pause.png) center no-repeat;
	height: 24px;
	left: 0;
	position: absolute;
	top: 0;
	width: 24px;
}
#pix_pag_ul {
	float: right;
	margin: 0;
	padding: 0;
}
#pix_pag_ul > li {
	cursor: pointer;
	display: block;
	.display: inline-block;
	float: left;
	list-style: none;
	margin: 0 10px 0 0;
	padding: 20px 8px 0;
	text-align: center;
	text-indent: -9999px;
	width: 16px;
}
#pix_pag_ul > li > span {
	background: #222;
	-webkit-border-radius: 8px;
	-moz-border-radius: 8px;
	border-radius: 8px;
	display: block;
	height: 16px;
	width: 16px;
}
#pix_pag_ul > li:hover > span > span {
	background: #ccc;
}
#pix_pag_ul > li > span > span {
	-webkit-border-radius: 8px;
	-moz-border-radius: 8px;
	border-radius: 8px;
	display: block;
	float: left;
	height: 8px;
	margin: 4px;
	width: 8px;
}
#pix_pag_ul > li.diapocurrent > span > span {
	background: #ff0;
	-webkit-border-radius: 8px;
	-moz-border-radius: 8px;
	border-radius: 8px;
}
#pix_pag_ul > li > .pix_thumb {
	border: 4px solid #f2f2f2;
	.border: 4px solid #e6e6e6;
	border: 4px solid #e6e6e6\9;
	-moz-box-shadow: 0 1px 8px #000;
	-webkit-box-shadow: 0 1px 8px #000;
	box-shadow: 0 1px 8px #000;
	height: 58px;
 	left: -17px;
	position: absolute;
	top: -40px;
	width: 58px;
}
#pix_pag_ul > li > .thumb_arrow {
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 4px solid  #e6e6e6;
	top: 26px;
	left: 12px;
	position: absolute;
}
.pix_relativize {
	overflow: hidden;
	position: relative;
}
.imgFake {
	cursor: pointer;
}
.elemHover {
	position: absolute;
}
.caption {
	background: rgba(0, 0, 0, 0.8);
    .filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#cc000000, endColorstr=#cc000000);
    filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#cc000000, endColorstr=#cc000000)\9;
	bottom: 20px;
	color: #fff;
	display: block;
	font-size: 13px;
	padding: 20px;
	width: 900px;
}
.ui-loader {
	display: none;
}

/* ------- */
#pix_pag_ul {
	float: right;
	margin: 0;
	position: absolute;
	padding: 0;
	left: 50%;
	bottom: 10px;
	transform: translateX(-50%);
}
#pix_pag_ul > li{
	padding-right: 15px;
	margin-right: 0;
}
#pix_pag_ul > li > .pix_thumb,#pix_pag_ul > li > .thumb_arrow{
	margin-top: -12px;
}
#pix_pag_ul > li > span{
	background-color: #ebebeb;
}
#pix_pag_ul > li.diapocurrent > span > span,#pix_pag_ul > li:hover > span > span{
	background-color: #229be8;
}

.theme2 #pix_pag_ul > li > span{
	height: 7px;
    width: 32px;
}
.theme2 #pix_pag_ul > li > span > span{
	width: 100%;
	margin: 0;
	border-radius: inherit;
}</style><style  data-label="posts_swiper" >body{font-family:"Lucida Sans Unicode","Lucida Grande",sans-serif;font-size:12px;line-height:20px}
section{display:block;overflow:hidden;position:relative}
.button{background:#014464;background:-moz-linear-gradient(top,#0d658e,#0c577a 50%,#014d71 51%,#003e5c);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#0e658e),color-stop(.5,#0c577a),color-stop(.5,#014d71),to(#003e5c));border:1px solid #368dbe;border-top:1px solid #c3d6df;-moz-border-radius:4px;-webkit-border-radius:4px;border-radius:4px;-moz-box-shadow:0 1px 3px #000;-webkit-box-shadow:0 1px 3px #000;box-shadow:0 1px 3px #000;color:#fff;display:block;font-size:12px;font-weight:700;height:30px;line-height:30px;padding:5px 20px;text-align:center;text-decoration:none;text-shadow:1px 1px 1px #000;text-transform:uppercase;width:auto}
.button2{background:#d9ae00;background:-moz-linear-gradient(top,#b28b06,#9c7705 50%,#9c7705 51%,#5c4100);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#b28b06),color-stop(.5,#9c7705),color-stop(.5,#9c7705),to(#5c4100));border:1px solid #c7a60c;border-top:1px solid #e5d51f}
.button3{background:#ffd838;background:-moz-linear-gradient(top,#edbf21,#c89b0f 50%,#9c7705 51%,#906706);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#edbf21),color-stop(.5,#c89b0f),color-stop(.5,#c89b0f),to(#906706));border:1px solid #c7a60c;border-top:1px solid #e5d51f}
.price_table{float:right;font-size:12px;margin:10px auto 0;padding:20px 0;position:relative;width:570px}
.price_table .price_column.highlighted{background:#ffd838;margin:-5px!important;padding:10px;z-index:2}
.price_table .price_column{display:block;margin:5px;float:left;position:absolute;width:180px;z-index:1}
.price_table .price_column>div{background:#eee}
.price_table .price_column>div>div{padding:10px 15px;border-bottom:1px solid #ccc;border-top:1px solid #f6f6f6}
.price_table .price_column>div>p{padding:10px 15px;border-bottom:1px solid #ccc;border-top:1px solid #f6f6f6}
.price_table .price_column>div>ul{padding:10px 15px;border-bottom:1px solid #ccc;border-top:1px solid #f6f6f6}
.price_table .price_title{background-color:#333;border-top:0!important;color:#fff;font-size:14px}
.price_table .highlighted .price_title{font-size:16px}
.price_table .price_price{font-size:36px;line-height:40px}
.price_table .highlighted .price_price{font-size:40px;line-height:44px}
.price_table .price_explanation{font-size:10px;line-height:13px;text-transform:uppercase}
.price_table .cusButton{background-color:#333;display:block;text-align:center}
.price_table li{padding:5px 0}
.price_table div.pix_check{background:url(images/demo/list-check-green.png) no-repeat 15px center;padding-left:38px!important}
.price_table div.pix_error{background:url(images/demo/list-error.png) no-repeat 15px center;padding-left:38px!important}
#aniSwiper .item-content{height:160px;width:100%;overflow:hidden}
.item-content .card-content,.pix_diapo,.pix_relativize,.theme2{height:100%;width:100%}
.diapo-wrap{height:182px;width:290px;padding:0}
.pix_diapo,.pix_relativize,.theme2,.theme2 img{height:100%!important;width:100%!important;margin:0!important;box-sizing:border-box}
#pix_pag{width:100%}
.theme2 .pix_pag_ul{display:flex}
.theme2 #pix_pag_ul>li>span{height:7px!important;width:7px!important}
#aniSwiper .col-diapo-text{position:absolute;padding:0;text-align:center;font-size:12px;display:block;color:#fff;background:rgba(255,255,255,.2);bottom:0;left:0;width:100%!important}
#aniSwiper img[label='_']{position:relative}
#aniSwiper img[label='_']::after{content:'';position:absolute;left:0;bottom:0;top:0;right:0;background-color:#229be8}
.fadeIn,.fromBottom,.fromLeft,.fromRight,.fromTop{z-index:4}
#aniSwiper .tac{text-align: center;}
#aniSwiper .pr{position: relative;}
#aniSwiper dd{margin: 0;}
#aniSwiper .full-fill{height: 100%;width: 100%;}
#aniSwiper .no-cover-bg{height:100%;width:100%;z-index:3;position:absolute;left:0;top:0;}
#aniSwiper .no-cover-img{height:100%;width:100%;z-index:3;position:absolute;left:0;top:0;}
#aniSwiper .no-cover-img{z-index:2;position:absolute;left:0;top:0;height:100%;width:100%;}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="木子、佳" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loader"><span></span><span> </span><span> </span><span></span></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/500657e4809a9b3db4ab120e66c980b7.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/galleryGroup/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas iconfont icon-liuyanban-05"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><div id="blog_name"><div class="back-home-button"><i class="fas fa-bars fa-fw"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">博客相关</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://lovelee.cn"> <img class="back-menu-item-icon" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://p9-passport.byteacctimg.com/img/mosaic-legacy/3791/5070639578~300x300.image"/><span class="back-menu-item-text">主页</span></a><a class="back-menu-item" href="/"> <img class="back-menu-item-icon" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://p9-passport.byteacctimg.com/img/mosaic-legacy/3791/5070639578~300x300.image"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" href="/"> <img class="back-menu-item-icon" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://p9-passport.byteacctimg.com/img/mosaic-legacy/3791/5070639578~300x300.image"/><span class="back-menu-item-text">vuePress</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">其他工具</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://vercel.com/jia0213"> <img class="back-menu-item-icon" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://p9-passport.byteacctimg.com/img/mosaic-legacy/3791/5070639578~300x300.image"/><span class="back-menu-item-text">vercel</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://account.mongodb.com/account/login?n=%2Fv2%2F62ecba0133adb75f9d6d5e95&amp;nextHash=%23metrics%2FreplicaSet%2F62fe118e666c8916bc682fed%2Fexplorer%2Ftest%2Fconfig%2Ffind"> <img class="back-menu-item-icon" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://p9-passport.byteacctimg.com/img/mosaic-legacy/3791/5070639578~300x300.image"/><span class="back-menu-item-text">mongodb-Cloud</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://console.cloud.tencent.com/"> <img class="back-menu-item-icon" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://p9-passport.byteacctimg.com/img/mosaic-legacy/3791/5070639578~300x300.image"/><span class="back-menu-item-text">腾讯云</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">其他分类</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://weibo.com/"> <img class="back-menu-item-icon" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://weibo.com/favicon.ico"/><span class="back-menu-item-text">微博</span></a></div></div></div></div><a id="site-name" href="/">木子、佳</a></div><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/galleryGroup/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas iconfont icon-liuyanban-05"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></nav><div id="post-info"><h1 class="post-title">ES-next使用说明</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-18T07:21:50.352Z" title="发表于 2022-09-18 07:21:50">2022-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-18T07:21:50.352Z" title="更新于 2022-09-18 07:21:50">2022-09-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ES-next使用说明"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/09/18/ES-next/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。</p>
<p>JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。</p>
<p>JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h5 id="ECMAScript-简介"><a href="#ECMAScript-简介" class="headerlink" title="ECMAScript 简介"></a>ECMAScript 简介</h5><h5 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h5><ul>
<li>let 和 const</li>
<li>箭头函数</li>
<li>类</li>
<li>默认参数</li>
<li>模板字符串</li>
<li>解构赋值</li>
<li>增强的对象字面量</li>
<li>For-of 循环</li>
<li>Promises</li>
<li>模块</li>
<li>String 新方法</li>
<li>Object 新方法</li>
<li>展开运算符</li>
<li>Set</li>
<li>Map</li>
<li>Generators</li>
</ul>
<h5 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h5><ul>
<li>Array.prototype.includes()</li>
<li>求幂运算符</li>
</ul>
<h5 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h5><ul>
<li>字符串填充</li>
<li>Object.values()</li>
<li>Object.entries()</li>
<li>Object.getOwnPropertyDescriptors()</li>
<li>尾逗号</li>
<li>共享内存 and 原子操作</li>
</ul>
<h5 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h5><ul>
<li>Rest/Spread Properties</li>
<li>Asynchronous iteration</li>
<li>Promise.prototype.finally()</li>
<li>正则表达式改进</li>
</ul>
<h5 id="ESNext"><a href="#ESNext" class="headerlink" title="ESNext"></a>ESNext</h5><ul>
<li>Array.prototype.{flat,flatMap}</li>
<li>try/catch 可选的参数绑定</li>
<li>Object.fromEntries()</li>
<li>String.prototype.{trimStart,trimEnd}</li>
<li>Symbol.prototype.description</li>
<li>JSON improvements</li>
<li>Well-formed JSON.stringify()</li>
<li>Function.prototype.toString()</li>
</ul>
<h4 id="ECMAScript-简介-1"><a href="#ECMAScript-简介-1" class="headerlink" title="ECMAScript 简介"></a>ECMAScript 简介</h4><p>每当阅读 JavaScript 相关的文章时，我都会经常遇到如下术语： ES3, ES5, ES6, ES7, ES8, ES2015, ES2016, ES2017, ECMAScript 2017, ECMAScript 2016, ECMAScript 2015 等等，那么它们是指代的是什么？</p>
<p>它们都是指代一个名为 ECMAScript 的标准。</p>
<p>JavaScript 就是基于这个标准实现的，ECMAScript 经常缩写为 ES。</p>
<p>除了 JavaScript 以外，其它基于 ECMAScript 实现语言包括：</p>
<ul>
<li>ActionScript ( Flash 脚本语言)，由于 Adobe 将于 2020 年末停止对 Flash 的支持而逐渐失去热度。</li>
<li>JScript (微软开发的脚本语言),在第一次浏览器大战最激烈的时期，JavaScript 只被Netscape所支持，微软必须为 Internet Explorer 构建自己的脚本语言。</li>
</ul>
<p>但是现在流传最广、影响最大的基于 ES 标准的语言实现无疑就是 JavaScript了</p>
<p>为啥要用这个奇怪的名字呢？Ecma International 是瑞士标准协会，负责制定国际标准。</p>
<p>JavaScript 被创建以后，经由 Netscape 和 Sun Microsystems 公司提交给欧洲计算机制造商协会进行标准化，被采纳的 ECMA-262 别名叫 ECMAScript。</p>
<blockquote>
<p>This press release by Netscape and Sun Microsystems (the maker of Java) might help figure out the name choice, which might include legal and branding issues by Microsoft which was in the committee, according to Wikipedia.</p>
</blockquote>
<p>IE9 之后微软的浏览器中就看不到对 JScript 这个命名的引用了，取而代之都统称为 JavaScript。</p>
<p>因此，截至201x，JavaScript 成为最流行的基于 ECMAScript 规范实现的语言。</p>
<h5 id="ECMAScript-当前的版本。"><a href="#ECMAScript-当前的版本。" class="headerlink" title="ECMAScript 当前的版本。"></a>ECMAScript 当前的版本。</h5><p>目前的最新的 ECMAScript 版本是 ES2018。</p>
<p>于 2018 年 6 月发布。</p>
<h5 id="TC39-是什么？"><a href="#TC39-是什么？" class="headerlink" title="TC39 是什么？"></a>TC39 是什么？</h5><p>TC39（Technical Committee 39）是一个推动 JavaScript 发展的委员会。</p>
<p>TC39的成员包括各个主流浏览器厂商以及业务与浏览器紧密相连的公司，其中包括 Mozilla，Google ，Facebook，Apple，Microsoft，Intel，PayPal，SalesForce等。</p>
<p>每个标准版本提案都必须经过四个不同的阶段，这里有详细的解释。</p>
<h5 id="ES-Versions"><a href="#ES-Versions" class="headerlink" title="ES Versions"></a>ES Versions</h5><p>令我费解的是 ES 版本的命名依据有时根据迭代的版本号，有时却根据年份来进行命名。而这个命名的不确定性又使得人们更加容易混淆 JS/ES 这个两个概念😄。</p>
<p>在 ES2015 之前，ECMAScript 各个版本的命名规范通常与跟着标准的版本更新保持一致。因此，2009年 ECMAScript 规范更新以后的的正式版本是 ES5。</p>
<blockquote>
<p>Why does this happen? During the process that led to ES2015, the name was changed from ES6 to ES2015, but since this was done late, people still referenced it as ES6, and the community has not left the edition naming behind — the world is still calling ES releases by edition number.</p>
</blockquote>
<p>为什么会发生这一切？在ES2015诞生的过程中，名称由ES6更改为ES2015，但由于最终完成太晚，人们仍然称其为ES6，社区也没有将版本号完全抛之于后 — 世界仍然使用 ES 来定义版本号。</p>
<p>下图比较清晰的展示了版本号与年份的关联:</p>
<p><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/meG6Vo0Meviac0Jv4WVAlibeaSBib1Hh1Y019JXyUEnB5HXEdoX0pA7ibBnpNH5WNnYHqWoPcA84SZSicwkxV2poaeg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>接下来，我们来深入了解 JavaScript 自 ES5 以来增加的特性。</p>
<h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><p>ES2015 之前, var 是唯一可以用来声明变量的语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 0</span><br></pre></td></tr></table></figure>

<p>上面语句如果你遗漏了 var，那么你会把这个值（0）赋给一个未声明的变量，其中声明和未声明变量之间存在一些差异。</p>
<p>在现代浏览器开启严格模式时，给未声明的变量赋值会抛出 ReferenceError 异常，在较老的浏览器（或者禁用严格模式）的情况下，未声明的变量在执行赋值操作时会隐式的变为全局对象的属性。</p>
<p>当你声明一个变量却没有进行初始化，那么它的值直到你对它进行赋值操作之前都是 undefined 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a //typeof a === &#x27;undefined&#x27;</span><br></pre></td></tr></table></figure>

<p>你可以对一个变量进行多次重新声明，并覆盖它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">var a = 2</span><br></pre></td></tr></table></figure>

<p>你也可以在一条声明语句中一次声明多个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 1, b = 2</span><br></pre></td></tr></table></figure>

<p>作用域是变量可访问的代码部分。</p>
<p>在函数之外用 var 声明的会分配给全局对象，这种变量可以在全局作用域中被访问到。而在函数内部声明的变量只能在函数局部作用域被访问到，这类似于函数参数。</p>
<p>在函数中定义的局部变量名如何跟全局变量重名，那么局部变量的优先级更高，在函数内无法访问到同名的全局变量。</p>
<p>需要注意的是，var 是没有块级作用域（标识符是一对花括号）的，但是 var 是有函数作用域的，所以在新创建的块级作用域或者是函数作用域里面声明变量会覆盖全局同名变量，因为 var 在这两种情况下没有创建新的作用域。</p>
<p>在函数内部，其中定义的任何变量在所有函数代码中都是可见的，因为JavaScript在执行代码之前实际上将所有变量都移到了顶层（被称为悬挂的东西）。 在函数的内部定义的变量在整个函数作用域中都是可见（可访问），即使变量是在函数体末尾被声明，但是仍然可以再函数体开头部分被引用，因为 JavaScript存在变量提升机制。为避免混淆，请在函数开头声明变量，养成良好的编码规范。</p>
<h4 id="Using-let"><a href="#Using-let" class="headerlink" title="Using let"></a>Using let</h4><p>let 是ES2015中引入的新功能，它本质上是具有块级作用域的 var 。它可以被当前作用域（函数以及块级作用域）以及子级作用域访问到。</p>
<p>现代 JavaScript 开发者在 let 和 var 的选择中可能会更倾向于前者。</p>
<blockquote>
<p>如果 let 看起来是一个很抽象的术语，当你阅读到 let color = ‘red’ 这一段，因为使用 let 定义了color 为红色，那么这一切就变的有意义了。</p>
</blockquote>
<p>在任何函数之外用 let 声明变量，和 var相反的是 它并不会创建全局变量。</p>
<h4 id="Using-const"><a href="#Using-const" class="headerlink" title="Using const"></a>Using const</h4><p>使用变量 var 或 let 声明的变量可以被重新赋值。 使用 const 声明的变量一经初始化，它的值就永远不能再改变，即不可重新被赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a = &#x27;test&#x27;</span><br></pre></td></tr></table></figure>

<p>我们不能再为 a 进行赋值操作。然而，a 如果它是一个具有属性或者方法的对象，那么我们可以改变它的属性或者方法。</p>
<p>const 并不意味着具有不可变性，只是保证用 const 声明的变量的引用地址不被变更。</p>
<p>类似于 let，const 也具有块级作用域。</p>
<p>现代 JavaScript 开发者在遇到不会进行二次赋值的变量声明时，应该尽量使用 const。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数的引入极大的改变了代码的书写风格和一些工作机制。</p>
<p>在我看来，箭头函数很受开发者欢迎，现在很少在比较新的代码库中看到 function 关键字了，虽然它并未被废弃。</p>
<p>箭头函数看起来会更加的简洁，因为它允许你使用更短的语法来书写函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = function() &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = () =&gt; &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数体中只包含一条语句，你甚至可以省略大括号并直接书写这条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = () =&gt; doSomething()</span><br></pre></td></tr></table></figure>

<p>参数在括号中传递：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = (param1, param2) =&gt; doSomething(param1, param2)</span><br></pre></td></tr></table></figure>

<p>如果该函数只有一个参数，那么可以省略掉括号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = param =&gt; doSomething(param)</span><br></pre></td></tr></table></figure>

<p>由于这种简短的语法，使得我们可以更便捷的使用比较简短的函数</p>
<h4 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h4><p>箭头函数支持隐式返回：可以正常的 return 一个返回值但是可以不使用 return 关键字。</p>
<p>隐式返回只在函数体内只包含一条语句的情况下生效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = () =&gt; &#x27;test&#x27;</span><br><span class="line">myFunction() //&#x27;test&#x27;</span><br></pre></td></tr></table></figure>

<p>需要注意的一种情况，当返回一个对象时，记得将大括号括在括号中以避免产生歧义，误将其（大括号）解析为函数体的大括号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = () =&gt; (&#123; value: &#x27;test&#x27; &#125;)</span><br><span class="line">myFunction() //&#123;value: &#x27;test&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h4><p>this 可能是一个很难掌握的概念，因为它会根据上下文而进行变化，并且会在不同的 JavaScript的模式（是否为严格模式）下表现出差异。</p>
<p>理解 this 这个概念对于箭头函数的使用很重要，因为与常规函数相比，箭头函数的表现非常不同。</p>
<p>对象的方法为常规函数时，方法中的this指向这个对象，因此可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  model: &#x27;Fiesta&#x27;,</span><br><span class="line">  manufacturer: &#x27;Ford&#x27;,</span><br><span class="line">  fullName: function() &#123;</span><br><span class="line">    return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 car.fullName() 会返回 “Ford Fiesta”。</p>
<p>如果上述方法使用是是箭头函数，由于箭头中的 this 的作用域继承自执行上下文，箭头函数自身不绑定 this，因此 this 的值将在调用堆栈中查找，因此在此代码 car.fullName() 中不会返回常规函数那样的结果，实际会返回字符串 “undefined undefined”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  model: &#x27;Fiesta&#x27;,</span><br><span class="line">  manufacturer: &#x27;Ford&#x27;,</span><br><span class="line">  fullName: () =&gt; &#123;</span><br><span class="line">    return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，箭头函数不适合作为对象方法。</p>
<p>同样，箭头函数也不适合使用在作为创建构造函数，因为在实例化对象时会抛出 TypeError。</p>
<p>所以在不需要动态上下文时请使用常规函数。</p>
<p>当然，在事件监听器上使用箭头函数也会存在问题。因为 DOM 事件侦听器会自动将 this 与目标元素绑定，如果该事件处理程序的逻辑依赖 this，那么需要常规函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const link = document.querySelector(&#x27;#link&#x27;)</span><br><span class="line">link.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">  // this === window</span><br><span class="line">&#125;)</span><br><span class="line">const link = document.querySelector(&#x27;#link&#x27;)</span><br><span class="line">link.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">  // this === link</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Classes类"><a href="#Classes类" class="headerlink" title="Classes类"></a>Classes类</h4><p>JavaScript 实现继承的方式比较罕见：原型继承。原型继承虽然在我看来很棒，但与其它大多数流行的编程语言的继承实现机制不同，后者是基于类的。</p>
<p>因此 Java、Python 或其它语言的开发者很难理解原型继承的方式，因此 ECMAScript 委员会决定在原型继承之上实现 class 的语法糖，这样便于让其它基于类实现继承的语言的开发者更好的理解 JavaScript 代码。</p>
<p>注意：class 并没有对 JavaScript 底层做修改，你仍然可以直接访问对象原型。</p>
<h5 id="class-定义"><a href="#class-定义" class="headerlink" title="class 定义"></a>class 定义</h5><p>如下是一个 class 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    return &#x27;Hello, I am &#x27; + this.name + &#x27;.&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class 具有一个标识符，我们可以使用 new ClassIdentifier() 来创建一个对象实例。</p>
<p>初始化对象时，调用 constructor方法，并将参数传递给此方法。</p>
<p>类声明语句中也可以增加类需要的一些原型方法。在这种情况下 hello 是 Person 类的一个原型方法，可以在这个类的对象实例上调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const flavio = new Person(&#x27;Flavio&#x27;)</span><br><span class="line">flavio.hello()</span><br></pre></td></tr></table></figure>

<h4 id="Class-继承"><a href="#Class-继承" class="headerlink" title="Class 继承"></a>Class 继承</h4><p>一个子类可以 extend 另一个类，通过子类实例化出来的对象可以继承这两个类的所有方法。</p>
<p>如果子类中的方法与父类中的方法名重复，那么子类中的同名方法优先级更高：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Programmer extends Person &#123;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    return super.hello() + &#x27; I am a programmer.&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const flavio = new Programmer(&#x27;Flavio&#x27;)</span><br><span class="line">flavio.hello()</span><br></pre></td></tr></table></figure>

<p>(上述代码会打印出：“Hello, I am Flavio. I am a programmer.”)</p>
<p>类没有显示的类变量声明，但你必须在初始化构造函数 constructor 中去初始化类成员变量。</p>
<p>在子类中，你可以通过调用super()引用父类。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在类中，通常会把方法直接挂载到实例对象上，直接在实例对象上调用。</p>
<p>而静态方法则是直接使用类名来调用，而不是通过对象实例调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  static genericHello() &#123;</span><br><span class="line">    return &#x27;Hello&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.genericHello() //Hello</span><br></pre></td></tr></table></figure>

<h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>JavaScript 没有内置真正意义上的受保护的私有方法。</p>
<p>社区有解决方法，但我不会在这里做讲解。</p>
<h5 id="Getters-和-setters"><a href="#Getters-和-setters" class="headerlink" title="Getters 和 setters"></a>Getters 和 setters</h5><p>你可以通过增加方法 前缀 get 或者 set 创建一个 getter 和 setter，getter 和 setter会在你去获取特定值或者修改特定值的时候执行 get 或者 set内的相关方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    this._name = value</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this._name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你只有 getter，该属性无法被设置，并且设置此属性的操作都会被忽略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this._name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你只有一个 setter，则可以更改该值，但不能从外部访问它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    this._name = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>函数 doSomething 接收一个 param1 参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = (param1) =&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以给 param1 设定默认值，如果在调用函数时未传入参数，那么该参数自动设定未默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = (param1 = &#x27;test&#x27;) =&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这种机制同样适用于多个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = (param1 = &#x27;test&#x27;, param2 = &#x27;test2&#x27;) =&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如你的函数是一个具有特定属性的对象该怎么处理？</p>
<p>曾几何时，如果我们必须要取一个对象的特定属性值，为了做兼容处理（对象格式不正确），你必须在函数中添加一些代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const colorize = (options) =&gt; &#123;</span><br><span class="line">  if (!options) &#123;</span><br><span class="line">    options = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const color = (&#x27;color&#x27; in options) ? options.color : &#x27;yellow&#x27;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过解构，你可以给特定属性提供默认值，如此可以大大简化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const colorize = (&#123; color = &#x27;yellow&#x27; &#125;) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在调用 colorize 函数时没有传递任何对象，我们同样可以得到一个默认对象作为参数以供使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const spin = (&#123; color = &#x27;yellow&#x27; &#125; = &#123;&#125;) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串不同于 ES5 以前的版本，你可以用新颖的方式使用字符串。</p>
<p>这个语法看起来非常简便，只需要使用一个反引号替换掉单引号或双引号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a_string = `something`</span><br></pre></td></tr></table></figure>

<p>这个用法是独一无二的，因为它提供了许多普通字符串所没有的功能，如下：</p>
<ul>
<li>它为定义多行字符串提供了一个很好的语法</li>
<li>它提供了一种在字符串中插入变量和表达式的简单方法</li>
<li>它允许您创建带有模板标签的DSL (DSL意味着领域特定语言，例如：就如同在 React 中使用 styled-components 定义你组件的 CSS 一样)</li>
</ul>
<p>下面让我们深入每个功能的细节。</p>
<h5 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h5><p>在 ES6 标准之前，创建跨越两行的字符串只能在一行的结尾使用 ‘\’ 字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const string =</span><br><span class="line">  &#x27;first part \</span><br><span class="line">second part&#x27;</span><br></pre></td></tr></table></figure>

<p>这样使得你创建的字符串虽然跨越了两汉，但是渲染时仍然表现成一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first part second part</span><br></pre></td></tr></table></figure>

<p>需要渲染为多行的话，需要在一行结尾添加 ‘\n’，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const string =</span><br><span class="line">  &#x27;first line\n \</span><br><span class="line">second line&#x27;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const string = &#x27;first line\n&#x27; + &#x27;second line&#x27;</span><br></pre></td></tr></table></figure>

<p>模板字符串使得定义多行字符串变得更加简便。</p>
<p>一个模板字符串由一个反引号开始，你只需要按下回车键来创建新的一行，不需要插入特殊符号，最终的渲染效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const string = `Hey</span><br><span class="line">this</span><br><span class="line">string</span><br><span class="line">is awesome!`</span><br></pre></td></tr></table></figure>

<p>需要特别留意空格在这里是有特殊意义的，如果这样做的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const string = `First</span><br><span class="line">                Second`</span><br></pre></td></tr></table></figure>

<p>那么它会创建出像下面的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">First</span><br><span class="line">                Second</span><br></pre></td></tr></table></figure>

<p>有一个简单的方法可以修复这个问题，只需要将第一行置为空，然后添加了右边的翻译好后调用一个 trim() 方法，就可以消除第一个字符前的所有空格：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const string = `</span><br><span class="line">First</span><br><span class="line">Second`.trim()</span><br></pre></td></tr></table></figure>

<h5 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h5><p>模板字符串提供了插入变量和表达式的便捷方法</p>
<p>你只需要使用 ${…} 语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const var = &#x27;test&#x27;</span><br><span class="line">const string = `something $&#123;var&#125;` //something test</span><br></pre></td></tr></table></figure>

<p>在 ${} 里面你可以加入任何东西，甚至是表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const string = `something $&#123;1 + 2 + 3&#125;`</span><br><span class="line">const string2 = `something $&#123;foo() ? &#x27;x&#x27; : &#x27;y&#x27;&#125;`</span><br></pre></td></tr></table></figure>

<h5 id="Template-tags"><a href="#Template-tags" class="headerlink" title="Template tags"></a>Template tags</h5><p>标记模板可能是一个听起来不太有用的功能，但它实际上被许多流行的库使用，如 Styled Components 、Apollo 、GraphQL客户端/服务器库，因此了解它的工作原理至关重要。</p>
<p>在 Styled Components 模板标签中用于定义CSS字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Button = styled.button`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  background-color: black;</span><br><span class="line">  color: white;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>在 Apollo 中，模板标签用于定义 GraphQL 查询模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const query = gql`</span><br><span class="line">  query &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>上面两个例子中的styled.button和gql模板标签其实都是函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function gql(literals, ...expressions) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回一个字符串，可以是任意类型的计算结果。</p>
<p>字面量(literals)是一个包含了表达式插值的模板字面量的序列。 表达式(expressions)包含了所有的插值。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const string = `something $&#123;1 + 2 + 3&#125;`</span><br></pre></td></tr></table></figure>

<p>这个例子里面的字面量是由2个部分组成的序列。第1部分就是something，也就是第一个插值位置(${})之前的字符串，第2部分就是一个空字符串，从第1个插值结束的位置直到字符串的结束。</p>
<p>这个例子里面的表达式就是只包含1个部分的序列，也就是6。</p>
<p>举一个更复杂的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const string = `something</span><br><span class="line">another $&#123;&#x27;x&#x27;&#125;</span><br><span class="line">new line $&#123;1 + 2 + 3&#125;</span><br><span class="line">test`</span><br></pre></td></tr></table></figure>

<p>这个例子里面的字面量的序列里面，第1个部分是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;`something</span><br><span class="line">another `</span><br></pre></td></tr></table></figure>

<p>第2部分是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;`</span><br><span class="line">new line `</span><br></pre></td></tr></table></figure>

<p>第3部分是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;`</span><br><span class="line">test`</span><br></pre></td></tr></table></figure>

<p>这个例子里面的表达式包含了2个部分：x和6。</p>
<p>拿到了这些值的函数就可以对其做任意处理，这就是这个特性的威力所在。</p>
<p>比如最简单的处理就是字符串插值，把字面量和表达式拼接起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const interpolated = interpolate`I paid $&#123;10&#125;€`</span><br></pre></td></tr></table></figure>

<p>插值的过程就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function interpolate(literals, ...expressions) &#123;</span><br><span class="line">  let string = ``</span><br><span class="line">  for (const [i, val] of expressions) &#123;</span><br><span class="line">    string += literals[i] + val</span><br><span class="line">  &#125;</span><br><span class="line">  string += literals[literals.length - 1]</span><br><span class="line">  return string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>给定一个object，你可以抽取其中的一些值并且赋值给命名的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  firstName: &#x27;Tom&#x27;,</span><br><span class="line">  lastName: &#x27;Cruise&#x27;,</span><br><span class="line">  actor: true,</span><br><span class="line">  age: 54, //made up</span><br><span class="line">&#125;</span><br><span class="line">const &#123;firstName: name, age&#125; = person</span><br></pre></td></tr></table></figure>

<p>name和age就包含了对应的值。</p>
<p>这个语法同样可以用到数组当中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = [1,2,3,4,5]</span><br><span class="line">const [first, second] = a</span><br></pre></td></tr></table></figure>

<p>下面这个语句创建了3个新的变量，分别取的是数组a的第0、1、4下标对应的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [first, second, , , fifth] = a</span><br></pre></td></tr></table></figure>

<h5 id="更强大的对象字面量"><a href="#更强大的对象字面量" class="headerlink" title="更强大的对象字面量"></a>更强大的对象字面量</h5><p>ES2015赋予了对象字面量更大的威力。</p>
<p>简化了包含变量的语法<br>原来的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const something = &#x27;y&#x27;</span><br><span class="line">const x = &#123;</span><br><span class="line">  something: something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const something = &#x27;y&#x27;</span><br><span class="line">const x = &#123;</span><br><span class="line">  something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>原型可以这样指定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const anObject = &#123; y: &#x27;y&#x27; &#125;</span><br><span class="line">const x = &#123;</span><br><span class="line">  __proto__: anObject</span><br><span class="line">&#125;</span><br><span class="line">super()</span><br><span class="line">const anObject = &#123; y: &#x27;y&#x27;, test: () =&gt; &#x27;zoo&#x27; &#125;</span><br><span class="line">const x = &#123;</span><br><span class="line">  __proto__: anObject,</span><br><span class="line">  test() &#123;</span><br><span class="line">    return super.test() + &#x27;x&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">x.test() //zoox</span><br></pre></td></tr></table></figure>

<h5 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const x = &#123;</span><br><span class="line">  [&#x27;a&#x27; + &#x27;_&#x27; + &#x27;b&#x27;]: &#x27;z&#x27;</span><br><span class="line">&#125;</span><br><span class="line">x.a_b //z</span><br></pre></td></tr></table></figure>

<h4 id="For-of循环"><a href="#For-of循环" class="headerlink" title="For-of循环"></a>For-of循环</h4><p>2009年的ES5引入了forEach()循环。虽然很好用，但是它跟for循环一样，没法break。</p>
<p>ES2015引入了<strong>for-of</strong> 循环，就是在forEach的基础上加上了break的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//iterate over the value</span><br><span class="line">for (const v of [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">//get the index as well, using `entries()`</span><br><span class="line">for (const [i, v] of [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].entries()) &#123;</span><br><span class="line">  console.log(index) //index</span><br><span class="line">  console.log(value) //value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>留意一下const的使用。这个循环在每次迭代中都会创建一个新的作用域，所以我们可以使用const来代替let。</p>
<p>它跟for…in的区别在于：</p>
<ul>
<li>for…of遍历属性值</li>
<li>for…in遍历属性名</li>
</ul>
<h4 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h4><p>promise的一般定义： 它是一个代理，通过它可以最终得到一个值.</p>
<p>Promise是处理异步代码的一种方式，可以少写很多回调。</p>
<p>异步函数是建立在promise API上面的，所以理解Promise是一个基本的要求。</p>
<h5 id="promise的原理简述"><a href="#promise的原理简述" class="headerlink" title="promise的原理简述"></a>promise的原理简述</h5><p>一个promise被调用的时候，首先它是处于pending状态。在promise处理的过程中，调用的函数（caller）可以继续执行，直到promise给出反馈。</p>
<p>此时，调用的函数等待的promise结果要么是resolved状态，要么是rejected状态。但是由于JavaScript是异步的，所以promise处理的过程中，函数会继续执行。</p>
<h5 id="为什么JS-API使用promises"><a href="#为什么JS-API使用promises" class="headerlink" title="为什么JS API使用promises?"></a>为什么JS API使用promises?</h5><p>除了你的代码和第三方库的代码之外，promise在用在现代的Web API中，比如：</p>
<ul>
<li>电池API</li>
<li>Fetch API</li>
<li>Service Workers</li>
</ul>
<p>在现代的JavaScript中，不使用promise是不太可能的，所以我们来深入研究下promise吧。</p>
<h5 id="创建一个promise"><a href="#创建一个promise" class="headerlink" title="创建一个promise"></a>创建一个promise</h5><p>Promise API暴露了一个Promise构造函数，可以通过new Promise()来初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let done = true</span><br><span class="line">const isItDoneYet = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  if (done) &#123;</span><br><span class="line">    const workDone = &#x27;Here is the thing I built&#x27;</span><br><span class="line">    resolve(workDone)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const why = &#x27;Still working on something else&#x27;</span><br><span class="line">    reject(why)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>promise会检查done这个全局变量，如果为true，就返回一个resolved promise，否则就返回一个rejected promise。</p>
<p>通过resolve和reject，我们可以得到一个返回值，返回值可以是字符串也可以是对象。</p>
<h5 id="使用一个promise"><a href="#使用一个promise" class="headerlink" title="使用一个promise"></a>使用一个promise</h5><p>上面讲了怎么创建一个promise，下面就讲怎么使用（consume）这个promise。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const isItDoneYet = new Promise()</span><br><span class="line">//...</span><br><span class="line">const checkIfItsDone = () =&gt; &#123;</span><br><span class="line">  isItDoneYet</span><br><span class="line">    .then(ok =&gt; &#123;</span><br><span class="line">      console.log(ok)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">      console.error(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行checkIfItsDone()方法时，会执行isItDoneYet()这个promise，并且等待它resolve的时候使用then回调，如果有错误，就用catch回调来处理。</p>
<h5 id="链式promise"><a href="#链式promise" class="headerlink" title="链式promise"></a>链式promise</h5><p>一个promise可以返回另一个promise，从而创建promise链条（chain）。</p>
<p>一个很好的例子就是Fetch API，它是基于XMLHttpRequest API的一个上层API，我们可以用它来获取资源，并且在获取到资源的时候链式执行一系列promise。</p>
<p>Fetch API是一个基于promise的机制，调用fetch()相当于使用new Promise()来声明我们自己的promise。</p>
<p>链式promise的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const status = response =&gt; &#123;</span><br><span class="line">  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123;</span><br><span class="line">    return Promise.resolve(response)</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.reject(new Error(response.statusText))</span><br><span class="line">&#125;</span><br><span class="line">const json = response =&gt; response.json()</span><br><span class="line">fetch(&#x27;/todos.json&#x27;)</span><br><span class="line">  .then(status)</span><br><span class="line">  .then(json)</span><br><span class="line">  .then(data =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Request succeeded with JSON response&#x27;, data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Request failed&#x27;, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>在这个例子当中，我们调用fetch()，从根目录的todos.json文件中获取一系列的TODO项目，并且创建一个链式promise。</p>
<p>运行fetch()方法会返回一个response，它包含很多属性，我们从中引用如下属性：</p>
<ul>
<li>status, 一个数值，表示HTTP状态码</li>
<li>statusText, 一个状态消息，当请求成功的时候返回OK</li>
<li>response还有一个json()方法，它返回一个promise，返回内容转换成JSON后的结果。</li>
</ul>
<p>所以这些promise的调用过程就是：第一个promise执行一个我们定义的status()方法，检查response status，判断是否一个成功的响应(status在200和299之间)，如果不是成功的响应，就reject这个promise。</p>
<p>这个reject操作会导致整个链式promise跳过后面的所有promise直接到catch()语句，打印Request failed和错误消息。</p>
<p>如果这个promise成功了，它会调用我们定义的json()函数。因为前面的promise成功之后返回的response对象，我们可以拿到并作为第2个promise的参数传入。</p>
<p>在这个例子里面，我们返回了JSON序列化的数据，所以第3个promise直接接收这个JSON：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.then((data) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Request succeeded with JSON response&#x27;, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后我们把它打印到console。</p>
<h4 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h4><p>在上一节的的例子里面，我们有一个catch接在链式promise后面。</p>
<p>当promise链中的任意一个出错或者reject的时候，就会直接跳到promise链后面最近的catch()语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;Error&#x27;)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;)</span><br><span class="line">// or</span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  reject(&#x27;Error&#x27;)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="级联错误"><a href="#级联错误" class="headerlink" title="级联错误"></a>级联错误</h5><p>如果在catch()里面抛出一个错误，你可以在后面接上第二个catch()来处理这个错误，以此类推。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;Error&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    throw new Error(&#x27;Error&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="组织多个promise"><a href="#组织多个promise" class="headerlink" title="组织多个promise"></a>组织多个promise</h4><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>如果你要同时完成不同的promise,可以用Promise.all()来声明一系列的promise，然后当它们全部resolve的时候再执行一些操作。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const f1 = fetch(&#x27;/something.json&#x27;)</span><br><span class="line">const f2 = fetch(&#x27;/something2.json&#x27;)</span><br><span class="line">Promise.all([f1, f2])</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Array of results&#x27;, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>结合ES2015的解构赋值语法，你可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([f1, f2]).then(([res1, res2]) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Results&#x27;, res1, res2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然这不限于使用fetch， 这适用于任何promise.</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promise.race()运行所有传递进去的promise，但是只要有其中一个resolve了，就会运行回调函数，并且只执行一次回调，回调的参数就是第一个resolve的promise返回的结果。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promiseOne = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 500, &#x27;one&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">const promiseTwo = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 100, &#x27;two&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.race([promiseOne, promiseTwo]).then(result =&gt; &#123;</span><br><span class="line">  console.log(result) // &#x27;two&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>ES Module是用于处理模块的ECMAScript标准。</p>
<p>虽然 Node.js 多年来一直使用 CommonJS标准，但浏览器却从未有过模块系统，因为模块系统的决策首先需要 ECMAScript 标准化后才由浏览器厂商去实施实现。</p>
<p>这个标准化已经完成在 ES2015中，浏览器也开始实施实现这个标准，大家试图保持一致，以相同的方式工作。现在 ES Module 可以在 Chrome Safari Edge 和 Firefox（从60版本开始） 中使用。</p>
<p>模块非常酷，他们可以让你封装各种各样的功能，同时将这些功能作为库暴露给其它 JavaScript 文件使用。</p>
<h5 id="ES-模块语法"><a href="#ES-模块语法" class="headerlink" title="ES 模块语法"></a>ES 模块语法</h5><p>引入模块的语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import package from &#x27;module-name&#x27;</span><br></pre></td></tr></table></figure>

<p>CommonJS 则是这样使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const package = require(&#x27;module-name&#x27;)</span><br></pre></td></tr></table></figure>

<p>一个模块是一个 JavaScript 文件，这个文件使用 export 关键字 导出 一个或多个值（对象、函数或者变量）。例如，下面这个模块提供了一个将字符串变成大写形式的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uppercase.js</span><br><span class="line">export default str =&gt; str.toUpperCase()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，这个模块定义了唯一一个 default export，因此可以是一个匿名函数。否则，需要一个名称来和其它 导出 做区分。</p>
<p>现在，任何其它的 JavaScript 模块 可以通过 import 导入 uppercase.js 的这个功能。</p>
<p>一个 HTML 页面可以通过使用了特殊的 type=module 属性的 <code>&lt;script&gt;</code> 标签添加一个模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 这个模块导入的行为就像 <em>defer</em> 脚本加载一样。具体可以看 efficiently load JavaScript with defer and async</p>
</blockquote>
<p>需要特别注意的是，任何通过 type=”module” 载入的脚本会使用 严格模式 加载。</p>
<p>在这个例子中，uppercase.js 模块定义了一个 default export，因此当我们在导入它的时候，我们可以给他起一个任何我们喜欢的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import toUpperCase from &#x27;./uppercase.js&#x27;</span><br></pre></td></tr></table></figure>

<p>同时我们可以这样使用它:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toUpperCase(&#x27;test&#x27;) //&#x27;TEST&#x27;</span><br></pre></td></tr></table></figure>

<p>你也可以通过一个绝对路径来导入模块，下面是一个引用来自其它域底下定义的模块的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import toUpperCase from &#x27;https://flavio-es-modules-example.glitch.me/uppercase.js&#x27;</span><br></pre></td></tr></table></figure>

<p>下面同样是一些合法的 import语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; toUpperCase &#125; from &#x27;/uppercase.js&#x27;</span><br><span class="line">import &#123; toUpperCase &#125; from &#x27;../uppercase.js&#x27;</span><br></pre></td></tr></table></figure>

<p>下面是错误的使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; toUpperCase &#125; from &#x27;uppercase.js&#x27;</span><br><span class="line">import &#123; toUpperCase &#125; from &#x27;utils/uppercase.js&#x27;</span><br></pre></td></tr></table></figure>

<p>因为这里既不是使用绝对地址，也不是使用的相对地址。</p>
<h5 id="其它的-import-export-语法"><a href="#其它的-import-export-语法" class="headerlink" title="其它的 import/export 语法"></a>其它的 import/export 语法</h5><p>我们了解了上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default str =&gt; str.toUpperCase()</span><br></pre></td></tr></table></figure>

<p>这里生成了一个 default export。然而，你可以通过下面的语法在一个文件里面 导出 多个功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = 1</span><br><span class="line">const b = 2</span><br><span class="line">const c = 3</span><br><span class="line">export &#123; a, b, c &#125;</span><br></pre></td></tr></table></figure>

<p>另外一个模块可以使用下面的方式 import 导入所有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * from &#x27;module&#x27;</span><br></pre></td></tr></table></figure>

<p>你也可以通过解构赋值的方式仅仅 import 导出一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; a &#125; from &#x27;module&#x27;</span><br><span class="line">import &#123; a, b &#125; from &#x27;module&#x27;</span><br></pre></td></tr></table></figure>

<p>为了方便，你还可以使用 as 重命名任何 import 的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; a, b as two &#125; from &#x27;module&#x27;</span><br></pre></td></tr></table></figure>

<p>你可以导入模块中的默认出口以及通过名称导入任何非默认的出口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;</span><br></pre></td></tr></table></figure>

<p>这是一篇关于 ES 模块的文章，可以看一下： <a target="_blank" rel="noopener" href="https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html">https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html</a></p>
<h4 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS(跨域资源共享)"></a>CORS(跨域资源共享)</h4><p>进行远程获取模块的时候是遵循 CORS 机制的。这意味着当你引用远程模块的时候，必须使用合法的 CORS 请求头来允许跨域访问（例如：Access-Control-Allow-Origin: *）。</p>
<h5 id="对于不支持模块的浏览器应该怎么做？"><a href="#对于不支持模块的浏览器应该怎么做？" class="headerlink" title="对于不支持模块的浏览器应该怎么做？"></a>对于不支持模块的浏览器应该怎么做？</h5><p>结合 type=”module”、nomodule 一起使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script nomodule src=&quot;fallback.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="包装模块"><a href="#包装模块" class="headerlink" title="包装模块"></a>包装模块</h5><p>ES 模块是现代浏览器中的一大特性。这些特性是 ES6 规范中的一部分，要在浏览器中全部实现这些特性的路还很漫长。</p>
<p>我们现在就能使用它们！但是我们同样需要知道，有一些模块会对我们的页面性能产生性能影响。因为浏览器必须要在运行时执行它们。</p>
<p>Webpack 可能仍然会被大量使用，即使 ES 模块可以在浏览器中执行。但是语言内置这个特性对于客户端和 nodejs 在使用模块的时候是一种巨大的统一。</p>
<h4 id="新的字符串方法"><a href="#新的字符串方法" class="headerlink" title="新的字符串方法"></a>新的字符串方法</h4><p>任何字符串有了一些实例方法：</p>
<ul>
<li>repeat()</li>
<li>codePointAt()</li>
<li>repeat()</li>
</ul>
<p>根据指定的次数重复字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Ho&#x27;.repeat(3) //&#x27;HoHoHo&#x27;</span><br></pre></td></tr></table></figure>

<p>没有提供参数以及使用 0 作为参数的时候返回空字符串。如果给一个负数参数则会得到一个 RangeError 的错误。</p>
<h5 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h5><p>这个方法能用在处理那些需要 2 个 UTF-16 单元表示的字符上。</p>
<p>使用 charCodeAt 的话，你需要先分别得到两个 UTF-16 的编码然后结合它们。但是使用 codePointAt() 你可以直接得到整个字符。</p>
<p>下面是一个例子，中文的 “𠮷” 是由两个 UTF-16 编码组合而成的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;𠮷&quot;.charCodeAt(0).toString(16) //d842</span><br><span class="line">&quot;𠮷&quot;.charCodeAt(1).toString(16) //dfb7</span><br></pre></td></tr></table></figure>

<p>如果你将两个 unicode 字符组合起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\ud842\udfb7&quot; //&quot;𠮷&quot;</span><br></pre></td></tr></table></figure>

<p>你也可以用 codePointAt() 得到同样的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;𠮷&quot;.codePointAt(0) //20bb7</span><br></pre></td></tr></table></figure>

<p>如果你将得到的 unicode 编码组合起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\u&#123;20bb7&#125;&quot; //&quot;𠮷&quot;</span><br></pre></td></tr></table></figure>

<p>更多关于 Unicode 的使用方法，参考我的Unicode guide。</p>
<h4 id="新的对象方法"><a href="#新的对象方法" class="headerlink" title="新的对象方法"></a>新的对象方法</h4><p>ES2015 在 Object 类下引入了一些静态方法：</p>
<ul>
<li>Object.is() 确定两个值是不是同一个</li>
<li>Object.assign() 用来浅拷贝一个对象</li>
<li>Object.setPrototypeOf 设置一个对象的原型</li>
<li>Object.is()</li>
</ul>
<p>这个方法用来帮助比较对象的值：</p>
<p>使用方式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.is(a, b)</span><br></pre></td></tr></table></figure>

<p>返回值在下列情况之外一直是 false：</p>
<ul>
<li>a 和 b 是同一个对象</li>
<li>a 和 b 是相等的字符串(用同样的字符组合在一起的字符串是相等的)</li>
<li>a 和 b 是相等的数字</li>
<li>a 和 b 都是 undefined, null, NaN, true 或者都是 false</li>
<li>0 和 -0 在 JavaScript 里面是不同的值, 所以对这种情况要多加小心（例如在比较之前，使用 + 一元操作符将所有值转换成 +0）。</li>
</ul>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p>在 ES2015 版本中引入，这个方法拷贝所有给出的对象中的可枚举的自身属性到另一个对象中。</p>
<p>这个 API 的基本用法是创建一个对象的浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const copied = Object.assign(&#123;&#125;, original)</span><br></pre></td></tr></table></figure>

<p>作为浅拷贝，值会被复制，对象则是拷贝其引用（不是对象本身），因此当你修改了源对象的一个属性值，这个修改也会在拷贝出的对象中生效，因为内部引用的对象是相同的。:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const original = &#123;</span><br><span class="line">  name: &#x27;Fiesta&#x27;,</span><br><span class="line">  car: &#123;</span><br><span class="line">    color: &#x27;blue&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const copied = Object.assign(&#123;&#125;, original)</span><br><span class="line">original.name = &#x27;Focus&#x27;</span><br><span class="line">original.car.color = &#x27;yellow&#x27;</span><br><span class="line">copied.name //Fiesta</span><br><span class="line">copied.car.color //yellow</span><br></pre></td></tr></table></figure>

<p>我之前提到过，源对象可以是一个或者多个:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const wisePerson = &#123;</span><br><span class="line">  isWise: true</span><br><span class="line">&#125;</span><br><span class="line">const foolishPerson = &#123;</span><br><span class="line">  isFoolish: true</span><br><span class="line">&#125;</span><br><span class="line">const wiseAndFoolishPerson = Object.assign(&#123;&#125;, wisePerson, foolishPerson)</span><br><span class="line">console.log(wiseAndFoolishPerson) //&#123; isWise: true, isFoolish: true &#125;</span><br><span class="line">Object.setPrototypeOf()</span><br></pre></td></tr></table></figure>

<p>设置一个对象的原型。可以接受两个参数：对象以及原型。</p>
<p>使用方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(object, prototype)</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const animal = &#123;</span><br><span class="line">  isAnimal: true</span><br><span class="line">&#125;</span><br><span class="line">const mammal = &#123;</span><br><span class="line">  isMammal: true</span><br><span class="line">&#125;</span><br><span class="line">mammal.__proto__ = animal</span><br><span class="line">mammal.isAnimal //true</span><br><span class="line">const dog = Object.create(animal)</span><br><span class="line">dog.isAnimal  //true</span><br><span class="line">console.log(dog.isMammal)  //undefined</span><br><span class="line">Object.setPrototypeOf(dog, mammal)</span><br><span class="line">dog.isAnimal //true</span><br><span class="line">dog.isMammal //true</span><br></pre></td></tr></table></figure>

<h4 id="展开操作符"><a href="#展开操作符" class="headerlink" title="展开操作符"></a>展开操作符</h4><p>你可以展开一个数组、一个对象甚至是一个字符串，通过使用展开操作符 …。</p>
<p>让我们以数组来举例，给出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a = [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>你可以使用下面的方式创建出一个新的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const b = [...a, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<p>你也可以像下面这样创建一个数组的拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const c = [...a]</span><br></pre></td></tr></table></figure>

<p>这中方式对于对象仍然有效。使用下面的方式克隆一个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const newObj = &#123; ...oldObj &#125;</span><br></pre></td></tr></table></figure>

<p>用在字符串上的时候，展开操作符会以字符串中的每一个字符创建一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const hey = &#x27;hey&#x27;</span><br><span class="line">const arrayized = [...hey] // [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;y&#x27;]</span><br></pre></td></tr></table></figure>

<p>这个操作符有一些非常有用的应用。其中最重要的一点就是以一种非常简单的方式使用数组作为函数参数的能力：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const f = (foo, bar) =&gt; &#123;&#125;</span><br><span class="line">const a = [1, 2]</span><br><span class="line">f(...a)</span><br></pre></td></tr></table></figure>

<p>（在之前的语法规范中，你只能通过 f.apply(null, a) 的方式来实现，但是这种方式不是很友好和易读。）</p>
<p>剩余参数（rest element）在和数组解构（array destructuring）搭配使用的时候非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5]</span><br><span class="line">[first, second, ...others] = numbers</span><br></pre></td></tr></table></figure>

<p>下面是展开元素 （spread elements）:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5]</span><br><span class="line">const sum = (a, b, c, d, e) =&gt; a + b + c + d + e</span><br><span class="line">const sum = sum(...numbers)</span><br></pre></td></tr></table></figure>

<p>ES2018 引入了 剩余属性 ，同样的操作符但是只能用在对象上。</p>
<h4 id="剩余属性（Rest-properties）"><a href="#剩余属性（Rest-properties）" class="headerlink" title="剩余属性（Rest properties）:"></a>剩余属性（Rest properties）:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const &#123; first, second, ...others &#125; = &#123;</span><br><span class="line">  first: 1,</span><br><span class="line">  second: 2,</span><br><span class="line">  third: 3,</span><br><span class="line">  fourth: 4,</span><br><span class="line">  fifth: 5</span><br><span class="line">&#125;</span><br><span class="line">first // 1</span><br><span class="line">second // 2</span><br><span class="line">others // &#123; third: 3, fourth: 4, fifth: 5 &#125;</span><br></pre></td></tr></table></figure>

<p>属性展开（Spread properties）允许我们结合跟在 … 操作符之后对象的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const items = &#123; first, second, ...others &#125;</span><br><span class="line">items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>一个 Set 数据结构允许我们在一个容器里面增加数据。</p>
<p>一个 Set 是一个对象或者基础数据类型（strings、numbers或者booleans）的集合，你可以将它看作是一个 Map，其中值作为映射键，map 值始终为 true。</p>
<h5 id="初始化一个-Set"><a href="#初始化一个-Set" class="headerlink" title="初始化一个 Set"></a>初始化一个 Set</h5><p>Set 可以通过下面的方式初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set()</span><br></pre></td></tr></table></figure>

<h5 id="向-Set-中添加一项"><a href="#向-Set-中添加一项" class="headerlink" title="向 Set 中添加一项"></a>向 Set 中添加一项</h5><p>你可以使用 add 方法向 Set 中添加项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.add(&#x27;one&#x27;)</span><br><span class="line">s.add(&#x27;two&#x27;)</span><br></pre></td></tr></table></figure>

<p>Set 仅会存贮唯一的元素，因此多次调用 s.add(‘one’) 不会重复添加新的元素。</p>
<p>你不可以同时向 set 中加入多个元素。你需要多次调用 add() 方法。</p>
<h5 id="检查元素是否在-set-中"><a href="#检查元素是否在-set-中" class="headerlink" title="检查元素是否在 set 中"></a>检查元素是否在 set 中</h5><p>我们可以通过下面的方式检查元素是否在 set 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.has(&#x27;one&#x27;) //true</span><br><span class="line">s.has(&#x27;three&#x27;) //false</span><br></pre></td></tr></table></figure>

<h5 id="从-set-中删除一个元素："><a href="#从-set-中删除一个元素：" class="headerlink" title="从 set 中删除一个元素："></a>从 set 中删除一个元素：</h5><p>使用 delete() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.delete(&#x27;one&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="确定-set-中元素的数量"><a href="#确定-set-中元素的数量" class="headerlink" title="确定 set 中元素的数量"></a>确定 set 中元素的数量</h5><p>使用 size 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.size</span><br></pre></td></tr></table></figure>

<h5 id="删除-set-中的全部元素"><a href="#删除-set-中的全部元素" class="headerlink" title="删除 set 中的全部元素"></a>删除 set 中的全部元素</h5><p>使用 clear() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure>

<h5 id="对-set-进行迭代"><a href="#对-set-进行迭代" class="headerlink" title="对 set 进行迭代"></a>对 set 进行迭代</h5><p>使用 keys() 或者 values() 方法 - 它们等价于下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (const k of s.keys()) &#123;</span><br><span class="line">  console.log(k)</span><br><span class="line">&#125;</span><br><span class="line">for (const k of s.values()) &#123;</span><br><span class="line">  console.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>entries() 方法返回一个迭代器，你可以这样使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const i = s.entries()</span><br><span class="line">console.log(i.next())</span><br></pre></td></tr></table></figure>

<p>调用 i.next() 将会以 { value, done = false } 对象的形式返回每一个元素，直到迭代结束，这时 done 是 true。</p>
<p>你也可以调用 set 的 forEach() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.forEach(v =&gt; console.log(v))</span><br></pre></td></tr></table></figure>

<p>或者你就直接使用 for..of 循环吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (const k of s) &#123;</span><br><span class="line">  console.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用一些初始值初始化一个-set"><a href="#使用一些初始值初始化一个-set" class="headerlink" title="使用一些初始值初始化一个 set"></a>使用一些初始值初始化一个 set</h5><p>你可以使用一些值初始化一个 set：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set([1, 2, 3, 4])</span><br></pre></td></tr></table></figure>

<p>将 set 转换为一个数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a = [...s.keys()]</span><br><span class="line">// or</span><br><span class="line">const a = [...s.values()]</span><br></pre></td></tr></table></figure>

<h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>一个 WeakSet 是一个特殊的 Set.</p>
<p>在 set 中，元素不会被 gc（垃圾回收）。一个 weakSet 让它的所有元素都是可以被 gc 的。weakSet 中的每个键都是一个对象。当这个对象的引用消失的时候，对应的值就可以被 gc 了。</p>
<p>下面是主要的不同点：</p>
<ul>
<li>WeakSet 不可迭代</li>
<li>你不能清空 weakSet 中的所有元素</li>
<li>不能够得到 weakSet 的大小</li>
</ul>
<p>一个 weakSet 通常是在框架级别的代码中使用，仅仅暴露了下面的方法：</p>
<ul>
<li>add()</li>
<li>has()</li>
<li>delete()</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>一份map结构的数据允许我们建立数据和key的关系</p>
<h5 id="在ES6之前"><a href="#在ES6之前" class="headerlink" title="在ES6之前"></a>在ES6之前</h5><p>在引入Map之前，开发者通常把对象(Object)当Map使用，把某个object或value值与指定的key进行关联:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;&#125;</span><br><span class="line">car[&#x27;color&#x27;] = &#x27;red&#x27;</span><br><span class="line">car.owner = &#x27;Flavio&#x27;</span><br><span class="line">console.log(car[&#x27;color&#x27;]) //red</span><br><span class="line">console.log(car.color) //red</span><br><span class="line">console.log(car.owner) //Flavio</span><br><span class="line">console.log(car[&#x27;owner&#x27;]) //Flavio</span><br></pre></td></tr></table></figure>

<h5 id="引入Map之后"><a href="#引入Map之后" class="headerlink" title="引入Map之后"></a>引入Map之后</h5><p>ES6引入了Map数据结构，它为我们处理这种数据结构提供了一种合适的工具</p>
<p>Map的初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map()</span><br></pre></td></tr></table></figure>

<p>添加条目到Map中</p>
<p>你可以通过set()方法把条目设定到map中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.set(&#x27;color&#x27;, &#x27;red&#x27;)</span><br><span class="line">m.set(&#x27;age&#x27;, 2)</span><br></pre></td></tr></table></figure>

<p>通过key值从map中获取条目</p>
<p>你可以通过get()方法从map中取出条目:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const color = m.get(&#x27;color&#x27;)</span><br><span class="line">const age = m.get(&#x27;age&#x27;)</span><br></pre></td></tr></table></figure>

<p>通过key值从map中删除条目</p>
<p>使用delete()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.delete(&#x27;color&#x27;)</span><br></pre></td></tr></table></figure>

<p>从map中删除所有条目</p>
<p>使用clear()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.clear()</span><br></pre></td></tr></table></figure>

<p>通过key值检查map中是否含有某个条目</p>
<p>使用has()方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hasColor = m.has(&#x27;color&#x27;)</span><br></pre></td></tr></table></figure>

<p>获取map中的条目数量</p>
<p>使用 size 属性:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const size = m.size</span><br></pre></td></tr></table></figure>

<p>用value值初始化一个map</p>
<p>你可以用一组value来初始化一个map：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map([[&#x27;color&#x27;, &#x27;red&#x27;], [&#x27;owner&#x27;, &#x27;Flavio&#x27;], [&#x27;age&#x27;, 2]])</span><br></pre></td></tr></table></figure>

<p>Map 的key值</p>
<p>任何值(对象，数组，字符串，数字)都可以作为一个map的value值(使用key-value键值的形式)，任何值也可以用作key，即使是object对象。</p>
<p>如果你想通过get()方法从map中获取不存在的key，它将会返回undefined</p>
<p>在真实世界中你几乎不可能找到的诡异情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map()</span><br><span class="line">m.set(NaN, &#x27;test&#x27;)</span><br><span class="line">m.get(NaN) //test</span><br><span class="line">const m = new Map()</span><br><span class="line">m.set(+0, &#x27;test&#x27;)</span><br><span class="line">m.get(-0) //test</span><br></pre></td></tr></table></figure>

<p>使用Iterate迭代器获取map的keys值</p>
<p>Map提供了keys()方法，通过该方法我们可以迭代出所有的key值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (const k of m.keys()) &#123;</span><br><span class="line">  console.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Iterate迭代器获取map的values值</p>
<p>Map提供了values()方法，通过该方法我们可以迭代出所有的value值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (const v of m.values()) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Iterate迭代器获取key-value组成的键值对</p>
<p>Map提供了entries()方法，通过该方法我们可以迭代出所有的键值对:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (const [k, v] of m.entries()) &#123;</span><br><span class="line">  console.log(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法还可以简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (const [k, v] of m) &#123;</span><br><span class="line">  console.log(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将map的keys值转换为数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a = [...m.keys()]</span><br></pre></td></tr></table></figure>

<p>将map的values值转换为数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a = [...m.values()]</span><br></pre></td></tr></table></figure>

<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap是一种特殊的Map</p>
<p>在一个map对象中，定义在其上数据永远不会被垃圾回收，WeakMap替而代之的是它允许在它上面定义的数据可以自由的被垃圾回收走，WeakMap的每一个key都是一个对象，当指向该对象的指针丢失，与之对应的value就会被垃圾回收走。</p>
<p>这是WeakMap的主要不同处：</p>
<ul>
<li>你不可以在WeakMap上迭代keys值和values值(或者key-value键值对)</li>
<li>你不可以从WeakMap上清除所有条目</li>
</ul>
<h5 id="你不可以获取WeakMap的大小"><a href="#你不可以获取WeakMap的大小" class="headerlink" title="你不可以获取WeakMap的大小"></a>你不可以获取WeakMap的大小</h5><p>WeakMap提供了如下几种方法，这些方法的使用和在Map中一样：</p>
<ul>
<li>get(k)</li>
<li>set(k, v)</li>
<li>has(k)</li>
<li>delete(k)</li>
</ul>
<p>关于WeakMap的用例不如Map的用例那么明显，你可能永远也不会在哪里会用到它，但从实际出发，WeakMap可以构建不会干扰到垃圾回收机制的内存敏感性缓存，还可以满足封装的严谨性及信息的隐藏性需求。</p>
<h4 id="Generators生成器"><a href="#Generators生成器" class="headerlink" title="Generators生成器"></a>Generators生成器</h4><p>Generators是一种特殊的函数，它能够暂停自身的执行并在一段时间后再继续运行，从而允许其它的代码在此期间运行(有关该主题的详细说明，请参阅完整的“javascript生成器指南”)。</p>
<p>Generators的代码决定它必须等待，因此它允许队列中的其它代码运行，并保留“当它等待的事情”完成时恢复其操作的权力。</p>
<p>所有这一切都是通过一个简单的关键字“yield`”完成的。当生成器包含该关键字时，将停止执行。</p>
<p>generator生成器可以包含许多yield关键字，从而使自己能多次停止运行，它是由*function关键字标识(不要将其与C、C++或Go等低级语言中使用的取消指针引用操作符混淆)。</p>
<p>Generators支持JavaScript中全新的编程范式，包括：</p>
<ul>
<li>在generator运行时支持双向通信</li>
<li>不会“冻结”长期运行在程序中的while循环</li>
</ul>
<p>这里有一个解释generator如何工作的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function *calculator(input) &#123;</span><br><span class="line">  var doubleThat = 2 * (yield (input / 2))</span><br><span class="line">  var another = yield (doubleThat)</span><br><span class="line">  return (input * doubleThat * another)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先初始化它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const calc = calculator(10)</span><br></pre></td></tr></table></figure>

<p>然后我们在generator中开始进行iterator迭代：</p>
<h5 id="calc-next"><a href="#calc-next" class="headerlink" title="calc.next()"></a>calc.next()</h5><p>第一个迭代器开始了迭代，代码返回如下object对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done: false</span><br><span class="line">  value: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体过程如下：代码运行了函数，并把input=10传入到生成器构造函数中，该函数一直运行直到抵达yield，并返回yield输出的内容: input / 2 = 5，因此，我们得到的值为5，并告知迭代器还没有done(函数只是暂停了)。</p>
<p>在第二个迭代处，我们输入7：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc.next(7)</span><br></pre></td></tr></table></figure>

<p>然后我们得到了结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done: false</span><br><span class="line">  value: 14</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7被作为doubleThat的值，注意：你可能会把input/2作为输入参数，但这只是第一次迭代的返回值。现在我们忽略它，使用新的输入值7，并将其乘以2.</p>
<p>然后，我们得到第二个yield的值，它返回doubleThat，因此返回值为14。</p>
<p>在下一个，也是最后一个迭代器，我们输入100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc.next(100)</span><br></pre></td></tr></table></figure>

<p>这样我们得到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done: true</span><br><span class="line">  value: 14000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当迭代器完成时(没有更多的yield关键字)，我们返回input <em>doubleThat</em> another，这相当于10 <em>14</em>100。</p>
<p>这些都是在2015年的ES2015引入的特性，现在我们深入了解下ES2016，它的作用域范围更小。</p>
<h4 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h4><p>该特性引入了一种更简洁的语法，同来检查数组中是否包含指定元素。</p>
<p>对于ES6及更低版本，想要检查数组中是否包含指定元素，你不得不使用indexOf方法，它检查数组中的索引，如果元素不存在，它返回-1，由于-1被计算为true，你需对其进行取反操作，例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (![1,2].indexOf(3)) &#123;</span><br><span class="line">  console.log(&#x27;Not found&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ES7引入的新特性，我们可以如此做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (![1,2].includes(3)) &#123;</span><br><span class="line">  console.log(&#x27;Not found&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求幂运算符"><a href="#求幂运算符" class="headerlink" title="求幂运算符"></a>求幂运算符</h4><p>求幂运算符**相当于Math.pow()方法，但是它不是一个函数库，而是一种语言机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(4, 2) == 4 ** 2</span><br></pre></td></tr></table></figure>

<p>对于需要进行密集数学运算的程序来说，这个特性是个很好的增强，在很多语言中，**运算符都是标准(包括Python、Ruby、MATLAB、Perl等其它多种语言)。</p>
<p><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/meG6Vo0Meviac0Jv4WVAlibeaSBib1Hh1Y019JXyUEnB5HXEdoX0pA7ibBnpNH5WNnYHqWoPcA84SZSicwkxV2poaeg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>这些都是2016年引入的特性，现在让我们进入2017年。</p>
<h4 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h4><p>字符串填充的目的是给字符串添加字符，以使其达到指定长度。</p>
<p>ES2017引入了两个String方法：padStart()和padEnd()。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padStart(targetLength [, padString])</span><br><span class="line">padEnd(targetLength [, padString])</span><br></pre></td></tr></table></figure>

<p>使用例子：</p>
<p><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/meG6Vo0Meviac0Jv4WVAlibeaSBib1Hh1Y0m85zSGiciaAHf2qGiaiahoX3YRicf0tiaU2O6Ad0uWRyGxBurLYbry4bhs6Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p>该方法返回一个数组，数组包含了对象自己的所有属性，使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123; name: &#x27;Fred&#x27;, age: 87 &#125;</span><br><span class="line">Object.values(person) // [&#x27;Fred&#x27;, 87]</span><br></pre></td></tr></table></figure>

<p>Object.values()也可以作用于数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const people = [&#x27;Fred&#x27;, &#x27;Tony&#x27;]</span><br><span class="line">Object.values(people) // [&#x27;Fred&#x27;, &#x27;Tony&#x27;]</span><br></pre></td></tr></table></figure>

<h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><p>该方法返回一个数组，数组包含了对象自己的所有属性键值对，是一个[key, value]形式的数组，使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123; name: &#x27;Fred&#x27;, age: 87 &#125;</span><br><span class="line">Object.entries(person) // [[&#x27;name&#x27;, &#x27;Fred&#x27;], [&#x27;age&#x27;, 87]]</span><br></pre></td></tr></table></figure>

<p>Object.entries()也可以作用于数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const people = [&#x27;Fred&#x27;, &#x27;Tony&#x27;]</span><br><span class="line">Object.entries(people) // [[&#x27;0&#x27;, &#x27;Fred&#x27;], [&#x27;1&#x27;, &#x27;Tony&#x27;]]</span><br></pre></td></tr></table></figure>

<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>该方法返回自己(非继承)的所有属性描述符，JavaScript中的任何对象都有一组属性，每个属性都有一个描述符，描述符是属性的一组属性(attributes)，由以下部分组成：</p>
<ul>
<li>value: 熟悉的value值</li>
<li>writable: 属性是否可以被更改</li>
<li>get: 属性的getter函数, 当属性读取时被调用</li>
<li>set: 属性的setter函数, 当属性设置值时被调用</li>
<li>configurable: 如果为false, 不能删除该属性，除了它的value值以为，也不能更改任何属性。</li>
<li>enumerable: 该属性是否能枚举</li>
</ul>
<p>Object.getOwnPropertyDescriptors(obj)接受一个对象，并返回一个带有描述符集合的对象。</p>
<h4 id="In-what-way-is-this-useful"><a href="#In-what-way-is-this-useful" class="headerlink" title="In what way is this useful?"></a>In what way is this useful?</h4><p>ES6给我们提供了Object.assign()方法，它从一个一个或多个对象中复制所有可枚举的属性值，并返回一个新对象。</p>
<p>但是，这也存在着一个问题，因为它不能正确的复制一个具有非默认属性值的属性。</p>
<p>如果对象只有一个setter，那么它就不会正确的复制到一个新对象上，使用Object.assign()进行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const person1 = &#123;</span><br><span class="line">    set name(newName) &#123;</span><br><span class="line">        console.log(newName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将不会起作用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const person2 = &#123;&#125;</span><br><span class="line">Object.assign(person2, person1)</span><br></pre></td></tr></table></figure>

<p>但这将会起作用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const person3 = &#123;&#125;</span><br><span class="line">Object.defineProperties(person3,</span><br><span class="line">  Object.getOwnPropertyDescriptors(person1))</span><br></pre></td></tr></table></figure>

<p>通过一个简单的console控制台，你可以查看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person1.name = &#x27;x&#x27;</span><br><span class="line">&quot;x&quot;</span><br><span class="line">person2.name = &#x27;x&#x27;</span><br><span class="line">person3.name = &#x27;x&#x27;</span><br><span class="line">&quot;x&quot;</span><br></pre></td></tr></table></figure>

<p>person2没有setter，它没能复制进去，对象的浅复制限定也出现在Object.create()方法中。</p>
<h4 id="尾逗号"><a href="#尾逗号" class="headerlink" title="尾逗号"></a>尾逗号</h4><p>该特性允许在函数定义时有尾逗号，在函数使用时可以有尾逗号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = (var1, var2,) =&gt; &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">doSomething(&#x27;test2&#x27;, &#x27;test2&#x27;,)</span><br></pre></td></tr></table></figure>

<p>该改变将鼓励开发者停止“在一行开始时写逗号”的丑陋习惯</p>
<h4 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h4><p>JavaScript在很短的时间内从回调函数进化到Promise函数(ES2015)，并自从ES2017以来，异步JavaScript的async/wait语法变得更加简单。 异步函数是Promise和generator的结合，基本上，它是比Promise更高级的抽象，我再重复一般：async/await是基于Promise建立的</p>
<h5 id="为什么要引入async-await"><a href="#为什么要引入async-await" class="headerlink" title="为什么要引入async/await"></a>为什么要引入async/await</h5><p>它减少了围绕promise的引用，并打破了Promise — “不要打断链式调用”的限制。</p>
<p>当Promise在ES2015中引入时，它的本意是来解决异步代码的问题，它也确实做到了，但在ES2015和ES2017间隔的这两年中，大家意识到：Promise不是解决问题的终极方案。</p>
<p>Promise是为了解决著名的回调地狱而被引入的，但它本身也带来了使用复杂性和语法复杂性。</p>
<p>Promise是很好的原生特性，围绕着它开发人员可以探索出更好的语法，因此当时机成熟后，我们得到了async函数</p>
<p>async函数使代码看起来像是同步函数一样，但其背后却是异步和非堵塞的。</p>
<h5 id="它如何工作"><a href="#它如何工作" class="headerlink" title="它如何工作"></a>它如何工作</h5><p>一个async函数会返回一个promise，如下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const doSomethingAsync = () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(&#x27;I did something&#x27;), 3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你想要调用该函数时，你在前面加上了一个wait，这样调用就会被停止，直到该promise进行resolve或reject，需注意的是：外层函数必须定义为async，这是例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = async () =&gt; &#123;</span><br><span class="line">  console.log(await doSomethingAsync())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="一个上手示例"><a href="#一个上手示例" class="headerlink" title="一个上手示例"></a>一个上手示例</h5><p>这是一个使用async/await进行异步函数的简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const doSomethingAsync = () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(&#x27;I did something&#x27;), 3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const doSomething = async () =&gt; &#123;</span><br><span class="line">  console.log(await doSomethingAsync())</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;Before&#x27;)</span><br><span class="line">doSomething()</span><br><span class="line">console.log(&#x27;After&#x27;)</span><br></pre></td></tr></table></figure>

<p>上面的代码将会在浏览器的console中打印出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before</span><br><span class="line">After</span><br><span class="line">I did something //after 3s</span><br></pre></td></tr></table></figure>

<h4 id="关于-Promise"><a href="#关于-Promise" class="headerlink" title="关于 Promise"></a>关于 Promise</h4><p>将 async 关键字标记在任何函数上，意味着这个函数都将返回一个 Promise，即使这个函数没有显式的返回，它在内部也会返回一个 Promise，这就是下面这份代码有效的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const aFunction = async () =&gt; &#123;</span><br><span class="line">  return &#x27;test&#x27;</span><br><span class="line">&#125;</span><br><span class="line">aFunction().then(alert) // This will alert &#x27;test&#x27;</span><br></pre></td></tr></table></figure>

<p>下面的例子也一样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const aFunction = async () =&gt; &#123;</span><br><span class="line">  return Promise.resolve(&#x27;test&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">aFunction().then(alert) // This will alert &#x27;test&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="更易于阅读的代码"><a href="#更易于阅读的代码" class="headerlink" title="更易于阅读的代码"></a>更易于阅读的代码</h5><p>正如上述的例子，我们将它与普通回调函数或链式函数进行比较，我们的代码看起来非常的简单。</p>
<p>这是一个很简单的例子，当代码足够复杂时，它会产生更多的收益。</p>
<p>例如，使用 Promise 来获取 JSON 资源并解析它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const getFirstUserData = () =&gt; &#123;</span><br><span class="line">  return fetch(&#x27;/users.json&#x27;) // get users list</span><br><span class="line">    .then(response =&gt; response.json()) // parse JSON</span><br><span class="line">    .then(users =&gt; users[0]) // pick first user</span><br><span class="line">    .then(user =&gt; fetch(`/users/$&#123;user.name&#125;`)) // get user data</span><br><span class="line">    .then(userResponse =&gt; response.json()) // parse JSON</span><br><span class="line">&#125;</span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>

<p>这是使用 async/await 实现相同功能的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const getFirstUserData = async () =&gt; &#123;</span><br><span class="line">  const response = await fetch(&#x27;/users.json&#x27;) // get users list</span><br><span class="line">  const users = await response.json() // parse JSON</span><br><span class="line">  const user = users[0] // pick first user</span><br><span class="line">  const userResponse = await fetch(`/users/$&#123;user.name&#125;`) // get user data</span><br><span class="line">  const userData = await user.json() // parse JSON</span><br><span class="line">  return userData</span><br><span class="line">&#125;</span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>

<h5 id="串行多个异步功能"><a href="#串行多个异步功能" class="headerlink" title="串行多个异步功能"></a>串行多个异步功能</h5><p>async 函数非常容易，并且它的语法比 Promise 更易读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const promiseToDoSomething = () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(&#x27;I did something&#x27;), 10000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const watchOverSomeoneDoingSomething = async () =&gt; &#123;</span><br><span class="line">  const something = await promiseToDoSomething()</span><br><span class="line">  return something + &#x27; and I watched&#x27;</span><br><span class="line">&#125;</span><br><span class="line">const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; &#123;</span><br><span class="line">  const something = await watchOverSomeoneDoingSomething()</span><br><span class="line">  return something + &#x27; and I watched as well&#x27;</span><br><span class="line">&#125;</span><br><span class="line">watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I did something and I watched and I watched as well</span><br></pre></td></tr></table></figure>

<h4 id="更简单的调试"><a href="#更简单的调试" class="headerlink" title="更简单的调试"></a>更简单的调试</h4><p>调试 Promise 就很困难，因为调试器无法跨越异步代码，但调试 async/await 就非常的简单，调试器会像调试同步代码一样来处理它。</p>
<h5 id="共享内存和原子"><a href="#共享内存和原子" class="headerlink" title="共享内存和原子"></a>共享内存和原子</h5><p>WebWorkers 可以在浏览器中创建多线程程序。</p>
<p>它们通过事件的方式来传递消息，从 ES2017 开始，你可以使用 SharedArrayBuffer 在每一个 Worker 中和它们的创建者之间共享内存数组.</p>
<p>由于不知道写入内存部分需要多长的周期来广播，因此在读取值时，任何类型的写入操作都会完成，Atomics 可以避免竞争条件的发生。</p>
<p>关于它的更多细节可以在proposal中找到。</p>
<p>这是 ES2017，接下来我将介绍 ES2018 的功能。</p>
<h5 id="Rest-Spread-Properties"><a href="#Rest-Spread-Properties" class="headerlink" title="Rest/Spread Properties"></a>Rest/Spread Properties</h5><p>ES2015 引入了解构数组的方法，当你使用时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5]</span><br><span class="line">[first, second, ...others] = numbers</span><br></pre></td></tr></table></figure>

<p>and 展开参数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5]</span><br><span class="line">const sum = (a, b, c, d, e) =&gt; a + b + c + d + e</span><br><span class="line">const sum = sum(...numbers)</span><br></pre></td></tr></table></figure>

<p>ES2018 为对象引入了同样的功能。</p>
<p>解构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const &#123; first, second, ...others &#125; = &#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;</span><br><span class="line">first // 1</span><br><span class="line">second // 2</span><br><span class="line">others // &#123; third: 3, fourth: 4, fifth: 5 &#125;</span><br></pre></td></tr></table></figure>

<p>展开属性 允许通过组合在展开运算符之后传递的对象属性而创建新对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const items = &#123; first, second, ...others &#125;</span><br><span class="line">items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;</span><br></pre></td></tr></table></figure>

<h5 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h5><p>for-await-of 允许你使用异步可迭代对象做为循环迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for await (const line of readLines(filePath)) &#123;</span><br><span class="line">  console.log(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为它使用的了 await，因此你只能在 async 函数中使用它。</p>
<h5 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h5><p>当一个 Promise 是 fulfilled 时，它会一个接一个的调用 then。</p>
<p>如果在这个过程中发生了错误，则会跳过 then 而执行 catch。</p>
<p>而 finally() 允许你运行一些代码，无论是成功还是失败：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;file.json&#x27;)</span><br><span class="line">  .then(data =&gt; data.json())</span><br><span class="line">  .catch(error =&gt; console.error(error))</span><br><span class="line">  .finally(() =&gt; console.log(&#x27;finished&#x27;))</span><br></pre></td></tr></table></figure>

<h5 id="正则表达式改进"><a href="#正则表达式改进" class="headerlink" title="正则表达式改进"></a>正则表达式改进</h5><p>ES2018 对正则表达式引入了许多改进，这些都可以在 <a target="_blank" rel="noopener" href="https://flaviocopes.com/javascript-regular-expressions/">https://flaviocopes.com/javascript-regular-expressions/</a> 上找到。</p>
<p>以下是关于 ES2018 正则表达式改进的具体补充：</p>
<p>RegExp lookbehind assertions: 根据前面的内容匹配字符串</p>
<p>这是一个 lookahead: 你可以使用 ?= 来匹配字符串，后面跟随一个特定的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/Roger(?=Waters)/</span><br><span class="line">/Roger(?= Waters)/.test(&#x27;Roger is my dog&#x27;) //false</span><br><span class="line">/Roger(?= Waters)/.test(&#x27;Roger is my dog and Roger Waters is a famous musician&#x27;) //true</span><br></pre></td></tr></table></figure>

<p>?! 可以执行逆操作，如果匹配的字符串是no而不是在此后跟随特定的子字符串的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/Roger(?!Waters)/</span><br><span class="line">/Roger(?! Waters)/.test(&#x27;Roger is my dog&#x27;) //true</span><br><span class="line">/Roger(?! Waters)/.test(&#x27;Roger Waters is a famous musician&#x27;) //false</span><br></pre></td></tr></table></figure>

<p>Lookaheads 使用 ?= Symbol，它们已经可以用了。</p>
<p>Lookbehinds, 是一个新功能使用?&lt;=.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=Roger) Waters/</span><br><span class="line">/(?&lt;=Roger) Waters/.test(&#x27;Pink Waters is my dog&#x27;) //false</span><br><span class="line">/(?&lt;=Roger) Waters/.test(&#x27;Roger is my dog and Roger Waters is a famous musician&#x27;) //true</span><br></pre></td></tr></table></figure>

<p>如果一个 lookbehind 是否定，那么使用 ?&gt;!:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;!Roger) Waters/</span><br><span class="line">/(?&lt;!Roger) Waters/.test(&#x27;Pink Waters is my dog&#x27;) //true</span><br><span class="line">/(?&lt;!Roger) Waters/.test(&#x27;Roger is my dog and Roger Waters is a famous musician&#x27;) //false</span><br></pre></td></tr></table></figure>

<h5 id="Unicode属性转义-p-…-and-P-…"><a href="#Unicode属性转义-p-…-and-P-…" class="headerlink" title="Unicode属性转义 \p{…} and \P{…}"></a>Unicode属性转义 \p{…} and \P{…}</h5><p>在正则表达式模式中，你可以使用 \d 来匹配任意的数字，\s 来匹配任意不是空格的字符串，\w 来匹配任意字母数字字符串，以此类推。</p>
<blockquote>
<p>This new feature extends this concept to all Unicode characters introducing \p{} and is negation \P{}.</p>
</blockquote>
<p>这个新功能扩展了unicode字符，引入了 \p{} 来处理</p>
<p>任何 unicode 字符都有一组属性，例如 script 确认语言，ASCII 是一个布尔值用于检查 ASCII 字符。你可以将此属性方在() 中，正则表达式将来检查是否为真。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;ASCII&#125;+$/u.test(&#x27;abc&#x27;)   //✅</span><br><span class="line">/^\p&#123;ASCII&#125;+$/u.test(&#x27;ABC@&#x27;)  //✅</span><br><span class="line">/^\p&#123;ASCII&#125;+$/u.test(&#x27;ABC🙃&#x27;) //❌</span><br></pre></td></tr></table></figure>

<p>ASCII_Hex_Digit 是另一个布尔值，用于检查字符串是否包含有效的十六进制数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;ASCII_Hex_Digit&#125;+$/u.test(&#x27;0123456789ABCDEF&#x27;) //✅</span><br><span class="line">/^\p&#123;ASCII_Hex_Digit&#125;+$/u.test(&#x27;h&#x27;)                //❌</span><br></pre></td></tr></table></figure>

<p>此外，还有很多其它的属性。你可以在()中添加它们的名字来检查它们，包括 Uppercase, Lowercase, White_Space, Alphabetic, Emoji等等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Lowercase&#125;$/u.test(&#x27;h&#x27;) //✅</span><br><span class="line">/^\p&#123;Uppercase&#125;$/u.test(&#x27;H&#x27;) //✅</span><br><span class="line">/^\p&#123;Emoji&#125;+$/u.test(&#x27;H&#x27;)   //❌</span><br><span class="line">/^\p&#123;Emoji&#125;+$/u.test(&#x27;🙃🙃&#x27;) //✅</span><br></pre></td></tr></table></figure>

<p>除了二进制属性外，你还可以检查任何 unicode 字符属性以匹配特定的值，在这个例子中，我检查字符串是用希腊语还是拉丁字母写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\p&#123;Script=Greek&#125;+$/u.test(&#x27;ελληνικά&#x27;) //✅</span><br><span class="line">/^\p&#123;Script=Latin&#125;+$/u.test(&#x27;hey&#x27;) //✅</span><br></pre></td></tr></table></figure>

<p>阅读<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-regexp-unicode-property-escapes">https://github.com/tc39/proposal-regexp-unicode-property-escapes</a> 获取使用所有属性的详细信息。</p>
<p>Named capturing groups<br>In ES2018 a capturing group can be assigned to a name, rather than just being assigned a slot in the result array:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const re = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span><br><span class="line">const result = re.exec(&#x27;2015-01-02&#x27;)</span><br><span class="line">// result.groups.year === &#x27;2015&#x27;;</span><br><span class="line">// result.groups.month === &#x27;01&#x27;;</span><br><span class="line">// result.groups.day === &#x27;02&#x27;;</span><br><span class="line">The s flag for regular expressions</span><br><span class="line">The s flag, short for single line, causes the . to match new line characters as well. Without it, the dot matches regular characters but not the new line:</span><br><span class="line"></span><br><span class="line">/hi.welcome/.test(&#x27;hi\nwelcome&#x27;) // false</span><br><span class="line">/hi.welcome/s.test(&#x27;hi\nwelcome&#x27;) // true</span><br></pre></td></tr></table></figure>

<h4 id="ESNext-1"><a href="#ESNext-1" class="headerlink" title="ESNext"></a>ESNext</h4><p>什么是 ESNext ？</p>
<p>ESNext 是一个始终指向下一个版本 JavaScript 的名称。</p>
<p>当前的 ECMAScript 版本是 ES2018，它于2018年6月被发布。</p>
<p>历史上 JavaScript 标准化的版本都是在夏季被发布，因此我们可以预期 ECMAScript 2019 将于 2019 年的夏季被发布。</p>
<p>所以在编写本文时 ES2018 已经被发布，因此 ESNext 指的是 ES2019。</p>
<p>ECMAScript 标准的提案是分阶段组织的，第一到第三阶段属于功能性的孵化，第四阶段的功能才最终确定为新标准的一部分。</p>
<p>在编写本文时主要浏览器都实现了第四阶段大部分的功能，因此我将在本文中介绍它们。</p>
<p>其中一些变化主要在内部使用，但知道发生了什么这也很好。</p>
<p>第三阶段还有一些其它功能，可能会在接下来的几个月内升级到第四阶段，你可以在这个 Github 仓库中查看它们：<a target="_blank" rel="noopener" href="https://github.com/tc39/proposals%E3%80%82">https://github.com/tc39/proposals。</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.&#123;flat,flatMap&#125;</span><br></pre></td></tr></table></figure>

<p>flat() 是一个新的数组实例方法，它可以将多维数组转化成一维数组。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;Dog&#x27;, [&#x27;Sheep&#x27;, &#x27;Wolf&#x27;]].flat()</span><br><span class="line">//[ &#x27;Dog&#x27;, &#x27;Sheep&#x27;, &#x27;Wolf&#x27; ]</span><br></pre></td></tr></table></figure>

<p>默认情况下它只能将二维的数组转化成一维的数组，但你可以添加一个参数来确定要展开的级别，如果你将这个参数设置为 Infinity 那么它将展开无限的级别到一维数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;Dog&#x27;, [&#x27;Sheep&#x27;, [&#x27;Wolf&#x27;]]].flat()</span><br><span class="line">//[ &#x27;Dog&#x27;, &#x27;Sheep&#x27;, [ &#x27;Wolf&#x27; ] ]</span><br><span class="line">[&#x27;Dog&#x27;, [&#x27;Sheep&#x27;, [&#x27;Wolf&#x27;]]].flat(2)</span><br><span class="line">//[ &#x27;Dog&#x27;, &#x27;Sheep&#x27;, &#x27;Wolf&#x27; ]</span><br><span class="line">[&#x27;Dog&#x27;, [&#x27;Sheep&#x27;, [&#x27;Wolf&#x27;]]].flat(Infinity)</span><br><span class="line">//[ &#x27;Dog&#x27;, &#x27;Sheep&#x27;, &#x27;Wolf&#x27; ]</span><br></pre></td></tr></table></figure>

<p>如果你熟悉数组的 map 方法，那么你就知道使用它可以对数组的每个元素执行一个函数。</p>
<p>flatMap() 是一个新的数组实例方法，它将 flat() 和 map 结合了起来，当你期望在map函数中做一些处理时这非常有用，同时又希望结果如同 flat ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;My dog&#x27;, &#x27;is awesome&#x27;].map(words =&gt; words.split(&#x27; &#x27;))</span><br><span class="line">//[ [ &#x27;My&#x27;, &#x27;dog&#x27; ], [ &#x27;is&#x27;, &#x27;awesome&#x27; ] ]</span><br><span class="line">[&#x27;My dog&#x27;, &#x27;is awesome&#x27;].flatMap(words =&gt; words.split(&#x27; &#x27;))</span><br><span class="line">//[ &#x27;My&#x27;, &#x27;dog&#x27;, &#x27;is&#x27;, &#x27;awesome&#x27; ]</span><br></pre></td></tr></table></figure>

<h5 id="Optional-catch-binding"><a href="#Optional-catch-binding" class="headerlink" title="Optional catch binding"></a>Optional catch binding</h5><p>有时候我们并不需要将参数绑定到 try/catch 中。</p>
<p>在以前我们不得不这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  //handle error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使我们从来没有通过 e 来分析错误，但现在我们可以简单的省略它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">  //handle error</span><br><span class="line">&#125;</span><br><span class="line">Object.fromEntries()</span><br><span class="line">Objects have an entries() method, since ES2017.</span><br></pre></td></tr></table></figure>

<p>从 ES2017 开始 Object将有一个 entries() 方法。</p>
<p>它将返回一个包含所有对象自身属性的数组的数组，如[key, value]：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123; name: &#x27;Fred&#x27;, age: 87 &#125;</span><br><span class="line">Object.entries(person) // [[&#x27;name&#x27;, &#x27;Fred&#x27;], [&#x27;age&#x27;, 87]]</span><br></pre></td></tr></table></figure>

<p>ES2019 引入了一个新的 Object.fromEntries() 方法，它可以从上述的属性数组中创建一个新的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123; name: &#x27;Fred&#x27;, age: 87 &#125;</span><br><span class="line">const entries = Object.entries(person)</span><br><span class="line">const newPerson = Object.fromEntries(entries)</span><br><span class="line"></span><br><span class="line">person !== newPerson //true</span><br><span class="line">String.prototype.&#123;trimStart,trimEnd&#125;</span><br></pre></td></tr></table></figure>

<p>这些功能已经被 v8/Chrome 实现了近一年的时间，它将在 ES2019 中实现标准化。</p>
<h5 id="trimStart"><a href="#trimStart" class="headerlink" title="trimStart()"></a>trimStart()</h5><p>删除字符串首部的空格并返回一个新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Testing&#x27;.trimStart() //&#x27;Testing&#x27;</span><br><span class="line">&#x27; Testing&#x27;.trimStart() //&#x27;Testing&#x27;</span><br><span class="line">&#x27; Testing &#x27;.trimStart() //&#x27;Testing &#x27;</span><br><span class="line">&#x27;Testing&#x27;.trimStart() //&#x27;Testing&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="trimEnd"><a href="#trimEnd" class="headerlink" title="trimEnd()"></a>trimEnd()</h5><p>删除字符串尾部的空格并返回一个新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;Testing&#x27;.trimEnd() //&#x27;Testing&#x27;</span><br><span class="line">&#x27; Testing&#x27;.trimEnd() //&#x27; Testing&#x27;</span><br><span class="line">&#x27; Testing &#x27;.trimEnd() //&#x27; Testing&#x27;</span><br><span class="line">&#x27;Testing &#x27;.trimEnd() //&#x27;Testing&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h5><p>现在你可以使用 description 来获取 Symbol 的值，而不必使用 toString() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const testSymbol = Symbol(&#x27;Test&#x27;)</span><br><span class="line">testSymbol.description // &#x27;Test&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="JSON-improvements"><a href="#JSON-improvements" class="headerlink" title="JSON improvements"></a>JSON improvements</h5><p>在此之前 JSON 字符串中不允许使用分隔符（\u2028）和分隔符（\u2029）。</p>
<p>使用 JSON.parse 时，这些字符会导致一个 SyntaxError 错误，但现在它们可以正确的解析并如 JSON 标准定义的那样。</p>
<h5 id="Well-formed-JSON-stringify"><a href="#Well-formed-JSON-stringify" class="headerlink" title="Well-formed JSON.stringify()"></a>Well-formed JSON.stringify()</h5><p>修复 JSON.stringify() 在处理 UTF-8 code points (U+D800 to U+DFFF)。</p>
<p>在修复之前，调用 JSON.stringify() 将返回格式错误的 Unicode 字符，如（a “�”)。</p>
<p>现在你可以安全放心的使用 JSON.stringify() 转成字符串，也可以使用 JSON.parse() 将它转换回原始表示的形态。</p>
<h5 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h5><p>函数总会有一个 toString 方法，它将返回一个包含函数代码的字符串。</p>
<p>ES2019 对返回值做了修改，以避免剥离注释和其它字符串（如：空格），将更准确的表示函数的定义。</p>
<blockquote>
<p>If previously we had</p>
</blockquote>
<p>以前也许我们这样过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function /* this is bar */ bar () &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当时的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.toString() //&#x27;function bar() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.toString(); // &#x27;function /* this is bar */ bar () &#123;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>总结一下，我希望这篇文章可以帮助你了解一些最新的 JavaScript 以及我们在 2019 年即将看见的内容。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.lovelee.cn/">木子、佳</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.lovelee.cn/2022/09/18/ES-next/">https://blog.lovelee.cn/2022/09/18/ES-next/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.lovelee.cn" target="_blank">木子、佳</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ES6/">ES6</a><a class="post-meta__tags" href="/tags/ES-next/">ES-next</a></div><div class="post_share"><div class="social-share" data-image="https://img.gejiba.com/images/81f26ca2da3fc4f02ed4bfed1371414e.md.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wx-pay.jpg" target="_blank"><img class="post-qr-code-img" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="/img/wx-pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/ali-pay.jpg" target="_blank"><img class="post-qr-code-img" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="/img/ali-pay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/18/%E5%B9%B3%E6%97%B6%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%88%E6%9E%9C/"><img class="prev-cover" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/c5a4db9243b8e1465bf8995ea62f5b66.md.png" onerror="onerror=null;src='https://butterfly.js.org/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">平时做的一些效果</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/18/Express/"><img class="next-cover" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/f05de38e2709ebc4e9190c05bf62648d.md.png" onerror="onerror=null;src='https://butterfly.js.org/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Express使用说明</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/500657e4809a9b3db4ab120e66c980b7.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">木子、佳</div><div class="author-info__description">自律、自立、自由</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jia0213"><i class="fab fa-github"></i><span>查看 Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jia0213" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:984419317@qq.com" target="_blank" title="Email-邮箱"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center >欢迎来到我的<span style="color:red">blog</span></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ECMAScript-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">ECMAScript 简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES2015"><span class="toc-number">1.2.</span> <span class="toc-text">ES2015</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES2016"><span class="toc-number">1.3.</span> <span class="toc-text">ES2016</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES2017"><span class="toc-number">1.4.</span> <span class="toc-text">ES2017</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES2018"><span class="toc-number">1.5.</span> <span class="toc-text">ES2018</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ESNext"><span class="toc-number">1.6.</span> <span class="toc-text">ESNext</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ECMAScript-%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.</span> <span class="toc-text">ECMAScript 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ECMAScript-%E5%BD%93%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82"><span class="toc-number">2.1.</span> <span class="toc-text">ECMAScript 当前的版本。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TC39-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">TC39 是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES-Versions"><span class="toc-number">2.3.</span> <span class="toc-text">ES Versions</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let%E5%92%8Cconst"><span class="toc-number">3.</span> <span class="toc-text">let和const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-let"><span class="toc-number">4.</span> <span class="toc-text">Using let</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-const"><span class="toc-number">5.</span> <span class="toc-text">Using const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BF%94%E5%9B%9E"><span class="toc-number">7.</span> <span class="toc-text">隐式返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-this"><span class="toc-number">8.</span> <span class="toc-text">箭头函数中的 this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Classes%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">Classes类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#class-%E5%AE%9A%E4%B9%89"><span class="toc-number">9.1.</span> <span class="toc-text">class 定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-%E7%BB%A7%E6%89%BF"><span class="toc-number">10.</span> <span class="toc-text">Class 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">私有方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Getters-%E5%92%8C-setters"><span class="toc-number">12.1.</span> <span class="toc-text">Getters 和 setters</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">12.2.</span> <span class="toc-text">默认参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">13.</span> <span class="toc-text">模板字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">13.1.</span> <span class="toc-text">多行字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%80%BC"><span class="toc-number">13.2.</span> <span class="toc-text">插值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Template-tags"><span class="toc-number">13.3.</span> <span class="toc-text">Template tags</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">14.</span> <span class="toc-text">解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">14.1.</span> <span class="toc-text">更强大的对象字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">14.2.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">14.3.</span> <span class="toc-text">动态属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#For-of%E5%BE%AA%E7%8E%AF"><span class="toc-number">15.</span> <span class="toc-text">For-of循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promises"><span class="toc-number">16.</span> <span class="toc-text">Promises</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#promise%E7%9A%84%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-number">16.1.</span> <span class="toc-text">promise的原理简述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JS-API%E4%BD%BF%E7%94%A8promises"><span class="toc-number">16.2.</span> <span class="toc-text">为什么JS API使用promises?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AApromise"><span class="toc-number">16.3.</span> <span class="toc-text">创建一个promise</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AApromise"><span class="toc-number">16.4.</span> <span class="toc-text">使用一个promise</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8Fpromise"><span class="toc-number">16.5.</span> <span class="toc-text">链式promise</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">17.</span> <span class="toc-text">处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E9%94%99%E8%AF%AF"><span class="toc-number">17.1.</span> <span class="toc-text">级联错误</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%BB%87%E5%A4%9A%E4%B8%AApromise"><span class="toc-number">18.</span> <span class="toc-text">组织多个promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-all"><span class="toc-number">18.1.</span> <span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-race"><span class="toc-number">18.2.</span> <span class="toc-text">Promise.race()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">19.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ES-%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95"><span class="toc-number">19.1.</span> <span class="toc-text">ES 模块语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%9A%84-import-export-%E8%AF%AD%E6%B3%95"><span class="toc-number">19.2.</span> <span class="toc-text">其它的 import&#x2F;export 语法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="toc-number">20.</span> <span class="toc-text">CORS(跨域资源共享)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E4%B8%8D%E6%94%AF%E6%8C%81%E6%A8%A1%E5%9D%97%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">20.1.</span> <span class="toc-text">对于不支持模块的浏览器应该怎么做？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E6%A8%A1%E5%9D%97"><span class="toc-number">20.2.</span> <span class="toc-text">包装模块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-number">21.</span> <span class="toc-text">新的字符串方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#codePointAt"><span class="toc-number">21.1.</span> <span class="toc-text">codePointAt()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">22.</span> <span class="toc-text">新的对象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-assign"><span class="toc-number">22.1.</span> <span class="toc-text">Object.assign()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%95%E5%BC%80%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">23.</span> <span class="toc-text">展开操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%B1%9E%E6%80%A7%EF%BC%88Rest-properties%EF%BC%89"><span class="toc-number">24.</span> <span class="toc-text">剩余属性（Rest properties）:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">25.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA-Set"><span class="toc-number">25.1.</span> <span class="toc-text">初始化一个 Set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91-Set-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%80%E9%A1%B9"><span class="toc-number">25.2.</span> <span class="toc-text">向 Set 中添加一项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8-set-%E4%B8%AD"><span class="toc-number">25.3.</span> <span class="toc-text">检查元素是否在 set 中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E-set-%E4%B8%AD%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9A"><span class="toc-number">25.4.</span> <span class="toc-text">从 set 中删除一个元素：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A-set-%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">25.5.</span> <span class="toc-text">确定 set 中元素的数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-set-%E4%B8%AD%E7%9A%84%E5%85%A8%E9%83%A8%E5%85%83%E7%B4%A0"><span class="toc-number">25.6.</span> <span class="toc-text">删除 set 中的全部元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9-set-%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3"><span class="toc-number">25.7.</span> <span class="toc-text">对 set 进行迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%BA%9B%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA-set"><span class="toc-number">25.8.</span> <span class="toc-text">使用一些初始值初始化一个 set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WeakSet"><span class="toc-number">25.9.</span> <span class="toc-text">WeakSet</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-number">26.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8ES6%E4%B9%8B%E5%89%8D"><span class="toc-number">26.1.</span> <span class="toc-text">在ES6之前</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5Map%E4%B9%8B%E5%90%8E"><span class="toc-number">26.2.</span> <span class="toc-text">引入Map之后</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakMap"><span class="toc-number">27.</span> <span class="toc-text">WeakMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%A0%E4%B8%8D%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96WeakMap%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">27.1.</span> <span class="toc-text">你不可以获取WeakMap的大小</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generators%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">28.</span> <span class="toc-text">Generators生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#calc-next"><span class="toc-number">28.1.</span> <span class="toc-text">calc.next()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-prototype-includes"><span class="toc-number">29.</span> <span class="toc-text">Array.prototype.includes()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%B9%82%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">30.</span> <span class="toc-text">求幂运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A1%AB%E5%85%85"><span class="toc-number">31.</span> <span class="toc-text">字符串填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-values"><span class="toc-number">32.</span> <span class="toc-text">Object.values()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-entries"><span class="toc-number">33.</span> <span class="toc-text">Object.entries()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getOwnPropertyDescriptors"><span class="toc-number">34.</span> <span class="toc-text">Object.getOwnPropertyDescriptors()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#In-what-way-is-this-useful"><span class="toc-number">35.</span> <span class="toc-text">In what way is this useful?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E9%80%97%E5%8F%B7"><span class="toc-number">36.</span> <span class="toc-text">尾逗号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0"><span class="toc-number">37.</span> <span class="toc-text">异步函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5async-await"><span class="toc-number">37.1.</span> <span class="toc-text">为什么要引入async&#x2F;await</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%83%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">37.2.</span> <span class="toc-text">它如何工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%B8%8A%E6%89%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">37.3.</span> <span class="toc-text">一个上手示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-Promise"><span class="toc-number">38.</span> <span class="toc-text">关于 Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%98%93%E4%BA%8E%E9%98%85%E8%AF%BB%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">38.1.</span> <span class="toc-text">更易于阅读的代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%8A%9F%E8%83%BD"><span class="toc-number">38.2.</span> <span class="toc-text">串行多个异步功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-number">39.</span> <span class="toc-text">更简单的调试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C%E5%8E%9F%E5%AD%90"><span class="toc-number">39.1.</span> <span class="toc-text">共享内存和原子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Rest-Spread-Properties"><span class="toc-number">39.2.</span> <span class="toc-text">Rest&#x2F;Spread Properties</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">39.3.</span> <span class="toc-text">异步迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-finally"><span class="toc-number">39.4.</span> <span class="toc-text">Promise.prototype.finally()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%B9%E8%BF%9B"><span class="toc-number">39.5.</span> <span class="toc-text">正则表达式改进</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unicode%E5%B1%9E%E6%80%A7%E8%BD%AC%E4%B9%89-p-%E2%80%A6-and-P-%E2%80%A6"><span class="toc-number">39.6.</span> <span class="toc-text">Unicode属性转义 \p{…} and \P{…}</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ESNext-1"><span class="toc-number">40.</span> <span class="toc-text">ESNext</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Optional-catch-binding"><span class="toc-number">40.1.</span> <span class="toc-text">Optional catch binding</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#trimStart"><span class="toc-number">40.2.</span> <span class="toc-text">trimStart()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#trimEnd"><span class="toc-number">40.3.</span> <span class="toc-text">trimEnd()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Symbol-prototype-description"><span class="toc-number">40.4.</span> <span class="toc-text">Symbol.prototype.description</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JSON-improvements"><span class="toc-number">40.5.</span> <span class="toc-text">JSON improvements</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Well-formed-JSON-stringify"><span class="toc-number">40.6.</span> <span class="toc-text">Well-formed JSON.stringify()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Function-prototype-toString"><span class="toc-number">40.7.</span> <span class="toc-text">Function.prototype.toString()</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/18/%E5%B9%B3%E6%97%B6%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%88%E6%9E%9C/" title="平时做的一些效果"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/c5a4db9243b8e1465bf8995ea62f5b66.md.png" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" alt="平时做的一些效果"/></a><div class="content"><a class="title" href="/2022/09/18/%E5%B9%B3%E6%97%B6%E5%81%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%88%E6%9E%9C/" title="平时做的一些效果">平时做的一些效果</a><time datetime="2022-09-18T08:16:45.000Z" title="发表于 2022-09-18 08:16:45">2022-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/18/ES-next/" title="ES-next使用说明"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/81f26ca2da3fc4f02ed4bfed1371414e.md.png" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" alt="ES-next使用说明"/></a><div class="content"><a class="title" href="/2022/09/18/ES-next/" title="ES-next使用说明">ES-next使用说明</a><time datetime="2022-09-18T07:21:50.352Z" title="发表于 2022-09-18 07:21:50">2022-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/18/Express/" title="Express使用说明"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/f05de38e2709ebc4e9190c05bf62648d.md.png" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" alt="Express使用说明"/></a><div class="content"><a class="title" href="/2022/09/18/Express/" title="Express使用说明">Express使用说明</a><time datetime="2022-09-18T07:21:50.352Z" title="发表于 2022-09-18 07:21:50">2022-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/18/Vue-cli4+/" title="Vue-cli4+"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/81f26ca2da3fc4f02ed4bfed1371414e.md.png" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" alt="Vue-cli4+"/></a><div class="content"><a class="title" href="/2022/09/18/Vue-cli4+/" title="Vue-cli4+">Vue-cli4+</a><time datetime="2022-09-18T07:21:50.352Z" title="发表于 2022-09-18 07:21:50">2022-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/18/axios/" title="axios使用说明"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/57a4d8ae3ef14210ee97bb4d8ea78ac8.md.png" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" alt="axios使用说明"/></a><div class="content"><a class="title" href="/2022/09/18/axios/" title="axios使用说明">axios使用说明</a><time datetime="2022-09-18T07:21:50.352Z" title="发表于 2022-09-18 07:21:50">2022-09-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2022 By 木子、佳</div><div class="footer_custom_text">Have a great day 😘!<p><a target="_blank" href="https://hexo.io/"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&amp;logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&amp;logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  loadingTime : 1200,
  endLoading: () => {
    if(preloader.loadingTime<=0){
      document.body.style.overflow = 'auto';
      document.getElementById('loading-box').classList.add("loaded");
      clearInterval(preloader.timer);
    }else{
      setTimeout(()=>{
        document.body.style.overflow = 'auto';
        document.getElementById('loading-box').classList.add("loaded");
      clearInterval(preloader.timer);
      },preloader.loadingTime)
    }
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  },
  timer:null,
  step : 10
}
preloader.timer = setInterval(()=>{
  preloader.loadingTime-=preloader.step;
},preloader.step)
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.lovelee.cn',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, {"placeholder":"欢迎留言"}))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.lovelee.cn',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
<script src="https://libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>

<script src="/js/flow_star.js"></script>
<script data-label="posts_swiper">/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 * 
 * Open source under the BSD License. 
 * 
 * Copyright © 2008 George McGinley Smith
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of 
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list 
 * of conditions and the following disclaimer in the documentation and/or other materials 
 * provided with the distribution.
 * 
 * Neither the name of the author nor the names of contributors may be used to endorse 
 * or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing['jswing'] = jQuery.easing['swing'];

jQuery.extend( jQuery.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		//alert(jQuery.easing.default);
		return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158; 
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 * 
 * Open source under the BSD License. 
 * 
 * Copyright © 2001 Robert Penner
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, this list of 
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list 
 * of conditions and the following disclaimer in the documentation and/or other materials 
 * provided with the distribution.
 * 
 * Neither the name of the author nor the names of contributors may be used to endorse 
 * or promote products derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
 */</script><script data-label="posts_swiper">/**
* hoverIntent r6 // 2011.02.26 // jQuery 1.5.1+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
* 
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne brian(at)cherne(dot)net
*/
(function($){$.fn.hoverIntent=function(f,g){var cfg={sensitivity:7,interval:100,timeout:0};cfg=$.extend(cfg,g?{over:f,out:g}:f);var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if((Math.abs(pX-cX)+Math.abs(pY-cY))<cfg.sensitivity){$(ob).unbind("mousemove",track);ob.hoverIntent_s=1;return cfg.over.apply(ob,[ev])}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=0;return cfg.out.apply(ob,[ev])};var handleHover=function(e){var ev=jQuery.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t)}if(e.type=="mouseenter"){pX=ev.pageX;pY=ev.pageY;$(ob).bind("mousemove",track);if(ob.hoverIntent_s!=1){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob)},cfg.interval)}}else{$(ob).unbind("mousemove",track);if(ob.hoverIntent_s==1){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob)},cfg.timeout)}}};return this.bind('mouseenter',handleHover).bind('mouseleave',handleHover)}})(jQuery);</script><script data-label="posts_swiper">!function($){$.fn.diapo=function(opts,callback){var defaults={selector:"div",fx:"random",mobileFx:"",slideOn:"random",gridDifference:250,easing:"easeInOutExpo",mobileEasing:"",loader:"pie",loaderOpacity:.8,loaderColor:"#dcdcdc",loaderBgColor:"#222222",pieDiameter:50,piePosition:"top:5px; right:5px",pieStroke:8,barPosition:"bottom",barStroke:5,navigation:!0,mobileNavigation:!0,navigationHover:!0,mobileNavHover:!0,commands:!1,mobileCommands:!0,pagination:!0,mobilePagination:!0,thumbs:!0,hover:!0,pauseOnClick:!0,rows:4,cols:6,slicedRows:8,slicedCols:12,time:3e3,transPeriod:1500,autoAdvance:!0,mobileAutoAdvance:!0,onStartLoading:function(){},onLoaded:function(){},onEnterSlide:function(){},onStartTransition:function(){}};function isMobile(){if(navigator.userAgent.match(/Android/i)||navigator.userAgent.match(/webOS/i)||navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPhone/i)||navigator.userAgent.match(/iPod/i))return!0}var opts=$.extend({},defaults,opts),elem=this,h=elem.height(),w=elem.width(),u,clickEv,autoAdv,navigation,navHover,commands,pagination,li;function loadimages(imgArr,callback){if(!$.browser.msie||$.browser.msie&&9==$.browser.version){var imagesLoaded=0;opts.onStartLoading.call(this),$.each(imgArr,(function(i,image){var img=new Image;img.onload=function(){++imagesLoaded==imgArr.length&&(opts.onLoaded.call(this),callback())},img.src=image}))}else callback()}if(isMobile()?(clickEv="click",autoAdv=opts.mobileAutoAdvance,navigation=opts.mobileNavigation,navHover=opts.mobileNavHover,commands=opts.commands,pagination=opts.pagination):(clickEv="click",autoAdv=opts.autoAdvance,navigation=opts.navigationHover,navHover=opts.navigationHover,commands=opts.commands,pagination=opts.pagination),0==autoAdv&&elem.addClass("stopped"),0!=elem.length){var selector=$("> "+opts.selector,elem).not("#pix_canvas").not("#pix_canvas_wrap").not("#pix_next").not("#pix_prev").not("#pix_commands");selector.wrapInner('<div class="pix_relativize" style="width:'+w+"px; height:"+h+'px" />');var amountSlide=selector.length,nav;function imgFake(){$("*[data-fake]",elem).each((function(){var t=$(this),imgFakeUrl=t.attr("data-fake"),wIf=t.width(),hIf=t.height(),imgFake=new Image(wIf,hIf);t.after($(imgFake).attr("src",imgFakeUrl).attr("class","imgFake"));var clone=t.clone();t.remove(),$(".elemToHide").show(),$(imgFake)[clickEv]((function(){$(this).hide().after(clone),$(".elemToHide").hide()}))}))}imgFake(),1==opts.hover&&(isMobile()||elem.hoverIntent({over:function(){elem.addClass("stopped")},out:function(){0!=autoAdv&&elem.removeClass("stopped")},timeout:0})),1==navHover&&(isMobile()?(elem.live("vmouseover",(function(){$("#pix_prev, #pix_next").animate({opacity:1},200)})),elem.live("vmouseout",(function(){$("#pix_prev, #pix_next").delay(500).animate({opacity:0},200)}))):elem.hover((function(){$("#pix_prev, #pix_next").stop(!0,!1).animate({opacity:1},200)}),(function(){$("#pix_prev, #pix_next").stop(!0,!1).animate({opacity:0},200)}))),$.fn.diapoStop=function(){autoAdv=!1,elem.addClass("stopped"),$("#pix_stop").length?$("#pix_stop").fadeOut(100,(function(){$("#pix_play").fadeIn(100),"none"!=opts.loader&&$("#pix_canvas").fadeOut(100)})):"none"!=opts.loader&&$("#pix_canvas").fadeOut(100)},$("#pix_stop").live("click",(function(){elem.diapoStop()})),$.fn.diapoPlay=function(){autoAdv=!0,elem.removeClass("stopped"),$("#pix_play").length?$("#pix_play").fadeOut(100,(function(){$("#pix_stop").fadeIn(100),"none"!=opts.loader&&$("#pix_canvas").fadeIn(100)})):"none"!=opts.loader&&$("#pix_canvas").fadeIn(100)},$("#pix_play").live("click",(function(){elem.diapoPlay()})),1==opts.pauseOnClick&&selector[clickEv]((function(){autoAdv=!1,elem.addClass("stopped"),$("#pix_stop").fadeOut(100,(function(){$("#pix_play").fadeIn(100),$("#pix_canvas").fadeOut(100)}))}));var allImg=new Array;$("img",elem).each((function(){allImg.push($(this).attr("src"))})),$.browser.msie||$("div, span, a",elem).each((function(){var bG=$(this).css("background"),bG2=$(this).attr("style");if(void 0!==bG&&!1!==bG&&-1!=bG.indexOf("url")){var bGstart=bG.lastIndexOf("url(")+4,bGfinish=bG.lastIndexOf(")");bG=(bG=(bG=bG.substring(bGstart,bGfinish)).replace(/'/g,"")).replace(/"/g,""),allImg.push(bG)}else if(void 0!==bG2&&!1!==bG2&&-1!=bG2.indexOf("url")){var bG2start=bG2.lastIndexOf("url(")+4,bG2finish=bG2.lastIndexOf(")");bG2=(bG2=(bG2=bG2.substring(bG2start,bG2finish)).replace(/'/g,"")).replace(/"/g,""),allImg.push(bG2)}})),loadimages(allImg,nextSlide)}function shuffle(arr){for(var j,x,i=arr.length;i;j=parseInt(Math.random()*i),x=arr[--i],arr[i]=arr[j],arr[j]=x);return arr}function isInteger(s){return Math.ceil(s)==Math.floor(s)}if($.browser.msie&&$.browser.version<9||"bar"==opts.loader){elem.append('<span id="pix_canvas" />');var canvas=$("#pix_canvas");"top"==opts.barPosition?canvas.css({top:0}):canvas.css({bottom:0}),canvas.css({position:"absolute",left:0,"z-index":1001,height:opts.barStroke,width:0,"background-color":opts.loaderColor})}else{var G_vmlCanvasManager,canvas,rad,radNew;if(elem.append('<canvas id="pix_canvas"></canvas>'),(canvas=document.getElementById("pix_canvas")).setAttribute("width",opts.pieDiameter),canvas.setAttribute("height",opts.pieDiameter),canvas.setAttribute("style","position:absolute; z-index:1002; "+opts.piePosition),canvas&&canvas.getContext){var ctx=canvas.getContext("2d");ctx.rotate(1.5*Math.PI),ctx.translate(-opts.pieDiameter,0)}}if("none"!=opts.loader&&0!=autoAdv||$("#pix_canvas, #pix_canvas_wrap").hide(),1==navigation&&(elem.append('<div id="pix_prev" />').append('<div id="pix_next" />'),$("#pix_prev").animate({opacity:0},200)),elem.after('<div id="pix_pag" />'),1==pagination)for($("#pix_pag").append('<ul id="pix_pag_ul" />'),li=0;li<amountSlide;li++)if($("#pix_pag_ul").append('<li id="pag_nav_'+li+'" style="position:relative; z-index:1002"><span><span>'+li+"</span></span></li>"),1==opts.thumbs){var dataThumb=selector.eq(li).attr("data-thumb"),newImg=new Image;newImg.src=dataThumb,$("li#pag_nav_"+li).append($(newImg).attr("class","pix_thumb").css("position","absolute").animate({opacity:0},0)),$("li#pag_nav_"+li+" > img").after('<div class="thumb_arrow" />'),$("li#pag_nav_"+li+" > .thumb_arrow").animate({opacity:0},0),isMobile()||($("#pix_pag_ul,#pix_pag_ul li,#pix_pag_ul li span,#pix_pag_ul li img,#pix_pag_ul li div").hover((function(){elem.addClass("stopped")}),(function(){0!=autoAdv&&elem.removeClass("stopped")})),$("#pix_pag li").hover((function(){elem.addClass("stopped"),$(".pix_thumb, .thumb_arrow",this).addClass("visible").stop(!0,!1).animate({"margin-top":-15,opacity:1},300,"easeOutQuad")}),(function(){0!=autoAdv&&elem.removeClass("stopped"),$(".pix_thumb, .thumb_arrow",this).removeClass("visible").stop(!0,!1).animate({"margin-top":-12,opacity:0},150)})))}function canvasLoader(){opts.onStartTransition.call(this),rad=0,$.browser.msie&&$.browser.version<9||"bar"==opts.loader?$("#pix_canvas").css({width:0}):ctx.clearRect(0,0,opts.pieDiameter,opts.pieDiameter)}function nextSlide(nav){elem.addClass("diaposliding");var vis=parseFloat($("> "+opts.selector+".diapocurrent",elem).not("#pix_canvas").not("#pix_canvas_wrap").not("#pix_next").not("#pix_prev").not("#pix_commands").index());if(nav>0)var i=nav-1;else if(vis==amountSlide-1)var i=0;else var i=vis+1;1==pagination&&($("#pix_pag li").removeClass("diapocurrent"),$("#pix_pag li").eq(i).addClass("diapocurrent"));var rows=opts.rows,cols=opts.cols,couples=1,difference=0,dataSlideOn,time,fx,easing,marginLeft=0,marginTop=0,randomFx=new Array("simpleFade","curtainTopLeft","curtainTopRight","curtainBottomLeft","curtainBottomRight","curtainSliceLeft","curtainSliceRight","blindCurtainTopLeft","blindCurtainTopRight","blindCurtainBottomLeft","blindCurtainBottomRight","blindCurtainSliceBottom","blindCurtainSliceTop","stampede","mosaic","mosaicReverse","mosaicRandom","mosaicSpiral","mosaicSpiralReverse","topLeftBottomRight","bottomRightTopLeft","bottomLeftTopRight","bottomLeftTopRight","scrollLeft","scrollRight","scrollTop","scrollBottom","scrollHorz");if(isMobile())var dataFx=selector.eq(i).attr("data-fx");else var dataFx=selector.eq(i).attr("data-mobileFx");if(void 0!==dataFx&&!1!==dataFx?fx=dataFx:"random"==(fx=isMobile()&&""!=opts.mobileFx?opts.mobileFx:opts.fx)?fx=(fx=shuffle(randomFx))[0]:(fx=fx).indexOf(",")>0&&(fx=(fx=shuffle(fx=(fx=fx.replace(/ /g,"")).split(",")))[0]),easing=isMobile()&&""!=opts.mobileEasing?opts.mobileEasing:opts.easing,void 0!==(dataSlideOn=selector.eq(i).attr("data-slideOn"))&&!1!==dataSlideOn)slideOn=dataSlideOn;else if("random"==opts.slideOn){var slideOn=new Array("next","prev");slideOn=(slideOn=shuffle(slideOn))[0]}else slideOn=opts.slideOn;switch(time=void 0!==(time=selector.eq(i).attr("data-time"))&&!1!==time?time:opts.time,$(elem).hasClass("diapostarted")||(fx="simpleFade",slideOn="next",$(elem).addClass("diapostarted")),fx){case"simpleFade":cols=1,rows=1;break;case"curtainTopLeft":case"curtainTopRight":case"curtainBottomLeft":case"curtainBottomRight":case"curtainSliceLeft":case"curtainSliceRight":cols=0==opts.slicedCols?opts.cols:opts.slicedCols,rows=1;break;case"blindCurtainTopLeft":case"blindCurtainTopRight":case"blindCurtainBottomLeft":case"blindCurtainBottomRight":case"blindCurtainSliceTop":case"blindCurtainSliceBottom":rows=0==opts.slicedRows?opts.rows:opts.slicedRows,cols=1;break;case"stampede":difference="-"+opts.transPeriod;break;case"mosaic":case"mosaicReverse":difference=opts.gridDifference;break;case"mosaicRandom":break;case"mosaicSpiral":case"mosaicSpiralReverse":difference=opts.gridDifference,couples=1.7;break;case"topLeftBottomRight":case"bottomRightTopLeft":case"bottomLeftTopRight":case"topRightBottomLeft":difference=opts.gridDifference,couples=6;break;case"scrollLeft":case"scrollRight":case"scrollTop":case"scrollBottom":case"scrollHorz":cols=1,rows=1}for(var cycle=0,blocks=rows*cols,leftScrap=w-Math.floor(w/cols)*cols,topScrap=h-Math.floor(h/rows)*rows,addLeft,addTop,tAppW=0,tAppH=0,arr=new Array,delay=new Array,order=new Array,w=elem.width();cycle<blocks;){arr.push(cycle),delay.push(cycle),elem.append('<div class="diapoappended" style="display:none; overflow:hidden; position:absolute; z-index:1000" />');var tApp=$(".diapoappended:eq("+cycle+")");tApp.find("iframe").remove(),"scrollLeft"==fx||"scrollRight"==fx||"scrollTop"==fx||"scrollBottom"==fx||"scrollHorz"==fx?selector.eq(i).clone().show().appendTo(tApp):"next"==slideOn?selector.eq(i).clone().show().appendTo(tApp):selector.eq(vis).clone().show().appendTo(tApp),addLeft=cycle%cols<leftScrap?1:0,cycle%cols==0&&(tAppW=0),addTop=Math.floor(cycle/cols)<topScrap?1:0,tApp.css({height:Math.floor(h/rows+addTop+1),left:tAppW,top:tAppH,width:Math.floor(w/cols+addLeft+1)}),$("> "+opts.selector,tApp).not("#pix_canvas").not("#pix_canvas_wrap").not("#pix_next").not("#pix_prev").not("#pix_commands").css({height:h,"margin-left":"-"+tAppW+"px","margin-top":"-"+tAppH+"px",width:w}),tAppW=tAppW+tApp.width()-1,cycle%cols==cols-1&&(tAppH=tAppH+tApp.height()-1),cycle++}switch(fx){case"curtainTopLeft":case"curtainBottomLeft":case"curtainSliceLeft":break;case"curtainTopRight":case"curtainBottomRight":case"curtainSliceRight":arr=arr.reverse();break;case"blindCurtainTopLeft":break;case"blindCurtainBottomLeft":arr=arr.reverse();break;case"blindCurtainSliceTop":case"blindCurtainTopRight":break;case"blindCurtainBottomRight":case"blindCurtainSliceBottom":arr=arr.reverse();break;case"stampede":arr=shuffle(arr);break;case"mosaic":break;case"mosaicReverse":arr=arr.reverse();break;case"mosaicRandom":arr=shuffle(arr);break;case"mosaicSpiral":var rows2=rows/2,x,y,z,n=0;for(z=0;z<rows2;z++){for(y=z,x=z;x<cols-z-1;x++)order[n++]=y*cols+x;for(x=cols-z-1,y=z;y<rows-z-1;y++)order[n++]=y*cols+x;for(y=rows-z-1,x=cols-z-1;x>z;x--)order[n++]=y*cols+x;for(x=z,y=rows-z-1;y>z;y--)order[n++]=y*cols+x}arr=order;break;case"mosaicSpiralReverse":var rows2=rows/2,x,y,z,n=blocks-1;for(z=0;z<rows2;z++){for(y=z,x=z;x<cols-z-1;x++)order[n--]=y*cols+x;for(x=cols-z-1,y=z;y<rows-z-1;y++)order[n--]=y*cols+x;for(y=rows-z-1,x=cols-z-1;x>z;x--)order[n--]=y*cols+x;for(x=z,y=rows-z-1;y>z;y--)order[n--]=y*cols+x}arr=order;break;case"topLeftBottomRight":for(var y=0;y<rows;y++)for(var x=0;x<cols;x++)order.push(x+y);delay=order;break;case"bottomRightTopLeft":for(var y=0;y<rows;y++)for(var x=0;x<cols;x++)order.push(x+y);delay=order.reverse();break;case"bottomLeftTopRight":for(var y=rows;y>0;y--)for(var x=0;x<cols;x++)order.push(x+y);delay=order;break;case"topRightBottomLeft":for(var y=0;y<rows;y++)for(var x=cols;x>0;x--)order.push(x+y);delay=order}$.each(arr,(function(index,value){switch(addLeft=value%cols<leftScrap?1:0,value%cols==0&&(tAppW=0),addTop=Math.floor(value/cols)<topScrap?1:0,$(".interval").text(fx),fx){case"simpleFade":height=h,width=w;break;case"curtainTopLeft":case"curtainTopRight":height=0,width=Math.floor(w/cols+addLeft+1),marginTop="-"+Math.floor(h/rows+addTop+1)+"px";break;case"curtainBottomLeft":case"curtainBottomRight":height=0,width=Math.floor(w/cols+addLeft+1),marginTop=Math.floor(h/rows+addTop+1)+"px";break;case"curtainSliceLeft":case"curtainSliceRight":height=0,width=Math.floor(w/cols+addLeft+1),marginTop=value%2==0?Math.floor(h/rows+addTop+1)+"px":"-"+Math.floor(h/rows+addTop+1)+"px";break;case"blindCurtainTopLeft":height=Math.floor(h/rows+addTop+1),width=0,marginLeft="-"+Math.floor(w/cols+addLeft+1)+"px";break;case"blindCurtainTopRight":height=Math.floor(h/rows+addTop+1),width=0,marginLeft=Math.floor(w/cols+addLeft+1)+"px";break;case"blindCurtainBottomLeft":height=Math.floor(h/rows+addTop+1),width=0,marginLeft="-"+Math.floor(w/cols+addLeft+1)+"px";break;case"blindCurtainBottomRight":height=Math.floor(h/rows+addTop+1),width=0,marginLeft=Math.floor(w/cols+addLeft+1)+"px";break;case"blindCurtainSliceBottom":case"blindCurtainSliceTop":height=Math.floor(h/rows+addTop+1),width=0,marginLeft=value%2==0?"-"+Math.floor(w/cols+addLeft+1)+"px":Math.floor(w/cols+addLeft+1)+"px";break;case"stampede":height=0,width=0,marginLeft=.2*w*(index%cols-(cols-Math.floor(cols/2)))+"px",marginTop=.2*h*(Math.floor(index/cols)+1-(rows-Math.floor(rows/2)))+"px";break;case"mosaic":height=0,width=0;break;case"mosaicReverse":height=0,width=0,marginLeft=Math.floor(w/cols+addLeft+1)+"px",marginTop=Math.floor(h/rows+addTop+1)+"px";break;case"mosaicRandom":case"mosaicSpiral":case"mosaicSpiralReverse":height=0,width=0,marginLeft=.5*Math.floor(w/cols+addLeft+1)+"px",marginTop=.5*Math.floor(h/rows+addTop+1)+"px";break;case"topLeftBottomRight":height=0,width=0;break;case"bottomRightTopLeft":height=0,width=0,marginLeft=Math.floor(w/cols+addLeft+1)+"px",marginTop=Math.floor(h/rows+addTop+1)+"px";break;case"bottomLeftTopRight":height=0,width=0,marginLeft=0,marginTop=Math.floor(h/rows+addTop+1)+"px";break;case"topRightBottomLeft":height=0,width=0,marginLeft=Math.floor(w/cols+addLeft+1)+"px",marginTop="-"+Math.floor(h/rows+addTop+1)+"px";break;case"scrollRight":height=h,width=w,marginLeft=-w;break;case"scrollLeft":height=h,width=w,marginLeft=w;break;case"scrollTop":height=h,width=w,marginTop=h;break;case"scrollBottom":height=h,width=w,marginTop=-h;break;case"scrollHorz":height=h,width=w,marginLeft=0==vis&&i==amountSlide-1?-w:vis<i||vis==amountSlide-1&&0==i?w:-w}var tApp=$(".diapoappended:eq("+value+")");function diapoeased(){if($(this).addClass("diapoeased"),$(".diapoeased").length==blocks){opts.onEnterSlide.call(this),$(".fromLeft, .fromRight, .fromTop, .fromBottom, .fadeIn").each((function(){$(this).css("visibility","hidden")})),selector.eq(i).show().css("z-index","999").addClass("diapocurrent"),selector.eq(vis).css("z-index","1").removeClass("diapocurrent");var lMoveIn=selector.eq(i).find(".fromLeft, .fromRight, .fromTop, .fromBottom, .fadeIn").length;0!=lMoveIn&&$(".diapocurrent .fromLeft, .diapocurrent .fromRight, .diapocurrent .fromTop, .diapocurrent .fromBottom, .diapocurrent .fadeIn").each((function(i,e){var easeMove=easing;""!=$(this).attr("data-easing")&&(easeMove=$(this).attr("data-easing"));var t=$(this);String.prototype._toNum=function(){return parseFloat(this)};var pos=t.position(),left=pos.left,top=pos.top,origonCss={l:t.css("left")._toNum()==left?left:t.css("left")._toNum(),t:t.css("top")._toNum()==top?top:t.css("top")._toNum(),r:t.css("right")._toNum(),b:t.css("bottom")._toNum(),w:t.css("width")._toNum(),h:t.css("height")._toNum()},wMoveIn=t.width(),hMoveIn=t.outerHeight();t.css("width",wMoveIn);var tClass=t.attr("class"),ind=t.index(),hRel=t.parents(".pix_relativize").height(),wRel=t.parents(".pix_relativize").width();-1!=tClass.indexOf("fromLeft")?(t.css({left:"-"+wRel+"px",right:"auto"}),t.css("visibility","visible").delay(time/lMoveIn*(.1*(ind-1))).animate({left:origonCss.l},time/lMoveIn*.2,easeMove)):-1!=tClass.indexOf("fromRight")?(t.css({left:wRel+"px",right:"auto"}),t.css("visibility","visible").delay(time/lMoveIn*(.1*(ind-1))).animate({left:origonCss.l},time/lMoveIn*.2,easeMove)):-1!=tClass.indexOf("fromTop")?(t.css({top:"-"+hRel+"px",bottom:"auto"}),t.css("visibility","visible").delay(time/lMoveIn*(.1*(ind-1))).animate({top:origonCss.t},time/lMoveIn*.2,easeMove)):-1!=tClass.indexOf("fromBottom")?(t.css({top:hRel+"px",bottom:"auto"}),t.css("visibility","visible").delay(time/lMoveIn*(.1*(ind-1))).animate({top:origonCss.t},time/lMoveIn*.2,easeMove)):-1!=tClass.indexOf("fadeIn")&&t.animate({opacity:0},0).css("visibility","visible").delay(time/lMoveIn*(.1*(ind-1))).animate({opacity:1},time/lMoveIn*.2,easeMove)})),$(".diapoappended").remove(),elem.removeClass("diaposliding"),selector.eq(vis).hide(),$("#pix_canvas").animate({opacity:opts.loaderOpacity},400),u=setInterval((function(){$.browser.msie&&$.browser.version<9||"bar"==opts.loader?(rad<=1&&!elem.hasClass("stopped")?rad+=.01:rad<=1&&elem.hasClass("stopped")?rad=rad:(elem.hasClass("stopped")||imgFake(),clearInterval(u),$("#pix_canvas").animate({opacity:0},200,(function(){setTimeout(canvasLoader,opts.transPeriod+difference),nextSlide()}))),canvas.css({width:w*rad})):(radNew=rad,ctx.clearRect(0,0,opts.pieDiameter,opts.pieDiameter),ctx.globalCompositeOperation="destination-over",ctx.beginPath(),ctx.arc(opts.pieDiameter/2,opts.pieDiameter/2,opts.pieDiameter/2-opts.pieStroke,0,2*Math.PI,!1),ctx.lineWidth=opts.pieStroke,ctx.strokeStyle=opts.loaderBgColor,ctx.stroke(),ctx.closePath(),ctx.globalCompositeOperation="source-over",ctx.beginPath(),ctx.arc(opts.pieDiameter/2,opts.pieDiameter/2,opts.pieDiameter/2-opts.pieStroke,0,2*Math.PI*radNew,!1),ctx.lineWidth=opts.pieStroke-4,ctx.strokeStyle=opts.loaderColor,ctx.stroke(),ctx.closePath(),rad<=1&&!elem.hasClass("stopped")?rad+=.01:rad<=1&&elem.hasClass("stopped")?rad=rad:(elem.hasClass("stopped")||imgFake(),clearInterval(u),$("#pix_canvas, #pix_canvas_wrap").animate({opacity:0},200,(function(){setTimeout(canvasLoader,opts.transPeriod+difference),nextSlide()}))))}),.01*time)}}start=(new Date).valueOf()+(opts.transPeriod+difference),void 0!==u&&(clearInterval(u),setTimeout(canvasLoader,opts.transPeriod+difference)),"scrollLeft"==fx||"scrollRight"==fx||"scrollTop"==fx||"scrollBottom"==fx||"scrollHorz"==fx?(tApp.delay((opts.transPeriod+difference)/blocks*delay[index]*couples*.5).css({display:"block",height:height,"margin-left":marginLeft,"margin-top":marginTop,width:width}).animate({height:Math.floor(h/rows+addTop+1),"margin-top":0,"margin-left":0,width:Math.floor(w/cols+addLeft+1)},opts.transPeriod-difference,easing,diapoeased),selector.eq(vis).delay((opts.transPeriod+difference)/blocks*delay[index]*couples*.5).animate({"margin-left":-1*marginLeft,"margin-top":-1*marginTop},opts.transPeriod-difference,easing,(function(){jQuery(this).css({"margin-top":0,"margin-left":0})}))):"next"==slideOn?tApp.delay((opts.transPeriod+difference)/blocks*delay[index]*couples*.5).css({display:"block",height:height,"margin-left":marginLeft,"margin-top":marginTop,width:width,opacity:0}).animate({height:Math.floor(h/rows+addTop+1),"margin-top":0,"margin-left":0,opacity:1,width:Math.floor(w/cols+addLeft+1)},opts.transPeriod-difference,easing,diapoeased):(selector.eq(i).show().css("z-index","999").addClass("diapocurrent"),selector.eq(vis).css("z-index","1").removeClass("diapocurrent"),tApp.delay((opts.transPeriod+difference)/blocks*delay[index]*couples*.5).css({display:"block",height:Math.floor(h/rows+addTop+1),"margin-top":0,"margin-left":0,opacity:1,width:Math.floor(w/cols+addLeft+1)}).animate({height:height,"margin-left":marginLeft,"margin-top":marginTop,width:width,opacity:0},opts.transPeriod-difference,easing,diapoeased)),1==navigation&&($("#pix_prev")[clickEv]((function(){if(!elem.hasClass("diaposliding")){var idNum=parseFloat($(".diapocurrent").index());clearInterval(u),imgFake(),$("#pix_canvas, #pix_canvas_wrap").animate({opacity:0},0),canvasLoader(),nextSlide(0!=idNum?idNum:amountSlide)}})),$("#pix_next")[clickEv]((function(){if(!elem.hasClass("diaposliding")){var idNum=parseFloat($(".diapocurrent").index());clearInterval(u),imgFake(),$("#pix_canvas, #pix_canvas_wrap").animate({opacity:0},0),canvasLoader(),nextSlide(idNum==amountSlide-1?1:idNum+2)}}))),isMobile()&&(elem.live("swipeleft",(function(event){if(!elem.hasClass("diaposliding")){var idNum=parseFloat($(".diapocurrent").index());clearInterval(u),imgFake(),$("#pix_canvas, #pix_canvas_wrap").animate({opacity:0},0),canvasLoader(),nextSlide(idNum==amountSlide-1?1:idNum+2)}})),elem.live("swiperight",(function(event){if(!elem.hasClass("diaposliding")){var idNum=parseFloat($(".diapocurrent").index());clearInterval(u),imgFake(),$("#pix_canvas, #pix_canvas_wrap").animate({opacity:0},0),canvasLoader(),nextSlide(0!=idNum?idNum:amountSlide)}}))),1==pagination&&$("#pix_pag li")[clickEv]((function(){if(!elem.hasClass("diaposliding")){var idNum=parseFloat($(this).index()),curNum;idNum!=parseFloat($(".diapocurrent").index())&&(clearInterval(u),imgFake(),$("#pix_canvas, #pix_canvas_wrap").animate({opacity:0},0),canvasLoader(),nextSlide(idNum+1))}})),1==opts.thumbs&&$("#pix_pag li .pix_thumb")[clickEv]((function(){if(!elem.hasClass("diaposliding")){var idNum=parseFloat($(this).parents("li").index()),curNum;idNum!=parseFloat($(".diapocurrent").index())&&(clearInterval(u),imgFake(),$("#pix_canvas, #pix_canvas_wrap").animate({opacity:0},0),canvasLoader(),nextSlide(idNum+1))}}))}))}1==commands&&($("#pix_pag").append('<div id="pix_commands" />'),$("#pix_pag").find("#pix_commands").append('<div id="pix_play" />').append('<div id="pix_stop" />'),1==autoAdv?($("#pix_play").hide(),$("#pix_stop").show()):($("#pix_stop").hide(),$("#pix_play").show())),1==navHover&&$("#pix_prev, #pix_next").animate({opacity:0},0),canvasLoader(),$(".fromLeft, .fromRight, .fromTop, .fromBottom, .fadeIn").each((function(){$(this).css("visibility","hidden")}))}}(jQuery);</script><script script-label="posts_swiper">
            function posts_swiper_injector_config(){
              var dom = `<div class="full-fill " ><a href="/2022/09/18/ES-next/" class="full-fill"><img class="full-fill" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/81f26ca2da3fc4f02ed4bfed1371414e.md.png"><div data-easing="easeOutExpo" class="fromTop col-diapo-text" ><dl><dt class="tac">ES-next使用说明</dt><dd class="tac" >ES-next使用说明</dd></dl></div></a></div><div class="full-fill " ><a href="/2022/09/18/Express/" class="full-fill"><img class="full-fill" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/f05de38e2709ebc4e9190c05bf62648d.md.png"><div data-easing="easeOutExpo" class="fromTop col-diapo-text" ><dl><dt class="tac">Express使用说明</dt></dl></div></a></div><div class="full-fill " ><a href="/2022/09/18/Vue-cli4+/" class="full-fill"><img class="full-fill" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/81f26ca2da3fc4f02ed4bfed1371414e.md.png"><div data-easing="easeOutExpo" class="fromBottom col-diapo-text" ><dl><dt class="tac">Vue-cli4+</dt></dl></div></a></div><div class="full-fill " ><a href="/2022/09/18/axios/" class="full-fill"><img class="full-fill" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/57a4d8ae3ef14210ee97bb4d8ea78ac8.md.png"><div data-easing="easeOutExpo" class="fromTop col-diapo-text" ><dl><dt class="tac">axios使用说明</dt></dl></div></a></div><div class="full-fill " ><a href="/2022/09/18/git+gitee/" class="full-fill"><img class="full-fill" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/cef2f45b3133a88def64a456f8ffd791.md.png"><div data-easing="easeOutExpo" class="fromRight col-diapo-text" ><dl><dt class="tac">git+gitee</dt></dl></div></a></div><div class="full-fill " ><a href="/2022/09/18/git1/" class="full-fill"><img class="full-fill" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/6f36c77d18c89031fac1e6eb37087012.md.png"><div data-easing="easeOutExpo" class="fromTop col-diapo-text" ><dl><dt class="tac">git使用（版本1）</dt></dl></div></a></div><div class="full-fill " ><a href="/2022/08/30/github_action_deploy_hexo/" class="full-fill"><img class="full-fill" onerror="this.onerror=null;this.src='https://butterfly.js.org/img/404.jpg'" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/e0f578073b7058be8d3fcbe736e993e4.md.png"><div data-easing="easeOutExpo" class="fromRight col-diapo-text" ><dl><dt class="tac">github action deploy hexo(based on butterfly)</dt><dd class="tac" >github action 部署博客</dd></dl></div></a></div>`;
              var mobile = false;
              var setting = JSON.parse(`{"fx":"random","time":3000,"transPeriod":1500,"navigationHover":true}`);
              var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
              var item_html = '<div class="card-widget card-posts-swiper" id="aniSwiper"><div class="item-content"><div class="theme2" style="height: 100%; width: 100%;"><div class="card-content" style="height: 100%; width: 100%;"><div class="pix_diapo" style="height: 100%; width: 100%;"><img class="entered loading" id="card-posts-swiper-loading" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/loading.gif" style="height: 100%; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>'; // pug 模版 整体插件outer
              console.log('已挂载posts_swiper')
              // parent_div_git.insertAdjacentHTML("afterbegin",item_html);
              var curUa = navigator.userAgent;
              start()
              $(window).on('resize',()=>{
                var ua = navigator.userAgent;
                // if(curUa == ua)return;
                clearInterval(window._posts_swiper);
                window._posts_swiper = setTimeout(() => {
                  start();
                }, 300);
              })
              function start(){
                var elm = $('.card-posts-swiper');
                var ua = navigator.userAgent;
                if(!mobile && /(android)|(ios)|(iphone)/i.test(ua)){
                  $(item_html).index();
                  $('.pix_diapo').html('');
                  elm.remove();
                }else{
                  elm.remove();
                  parent_div_git.insertAdjacentHTML("afterbegin",item_html);
                  setTimeout(()=>{
                    initPostsSwiper();
                  },1050);
                }
              }
              function initPostsSwiper(){
                $(item_html).find("img[label='_']").each(function(i,e){
                  let elm = getComputedStyle(e,"::after");
                  e.style.backgroundImage = $(e).css("backgroundImage");
                })
                $('.pix_diapo').html('').html(dom).diapo({
                  ...{
                    fx: 'random',
                    loader: 'none',
                    pagination: false,
                    time: 3000,
                    thumbs: false,
                    transPeriod: 800,
                    navigation: true,
                    mobileNavigation: false,
                    navigationHover: true,
                    mobileNavHover: false
                  },
                  ...setting
                }); 
                $('.pix_diapo').find("img[data-lazy-src]").each(function(i,e){
                  if($(e).attr('src') != $(e).attr('data-lazy-src'))$(e).attr('src',$(e).attr('data-lazy-src'));
                })
              }
            }
            var elist = 'null'.split(',');
            var cpage = location.pathname;
            var epage = 'all';
            var flag = 0;
            for (var i=0;i<elist.length;i++){
                if (cpage.includes(elist[i]))flag++;
            }
            if ((epage ==='all')&&(flag == 0)){
              if(document.querySelectorAll('script[script-label=posts_swiper]').length<=1){
                // console.log('已经有过了',document.querySelectorAll('script[script-label=posts_swiper]').length,'次');
                posts_swiper_injector_config();
              }
            }else if (epage === cpage){
              if(document.querySelectorAll('script[script-label=posts_swiper]').length<=1){
                // console.log('已经有过了',document.querySelectorAll('script[script-label=posts_swiper]').length,'次');
                posts_swiper_injector_config();
              }
            }
        </script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://img.gejiba.com/images/4ee8546f41d1d343d013fd7a4e86daf0.png);"> <a class="categoryBar-list-link" href="categories/前端/">前端</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr">-</span></li><li class="categoryBar-list-item" style="background:url(https://img.gejiba.com/images/81f26ca2da3fc4f02ed4bfed1371414e.md.png);"> <a class="categoryBar-list-link" href="categories/服务端/">服务端</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">-</span></li><li class="categoryBar-list-item" style="background:url(https://img.gejiba.com/images/57a4d8ae3ef14210ee97bb4d8ea78ac8.md.png);"> <a class="categoryBar-list-link" href="categories/学习/">学习</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">-</span></li><li class="categoryBar-list-item" style="background:url(https://img.gejiba.com/images/f05de38e2709ebc4e9190c05bf62648d.md.png);"> <a class="categoryBar-list-link" href="categories/微信公众号/">微信公众号</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">-</span></li><li class="categoryBar-list-item" style="background:url(https://img.gejiba.com/images/e0f578073b7058be8d3fcbe736e993e4.md.png);"> <a class="categoryBar-list-link" href="categories/微信小程序/">微信小程序</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">-</span></li><li class="categoryBar-list-item" style="background:url(https://img.gejiba.com/images/f6f00b06d2b8f74d17450329d3be5483.md.png);"> <a class="categoryBar-list-link" href="categories/电脑技巧/">电脑技巧</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">-</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/09/18/less/" alt=""><img width="48" height="48" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/e0f578073b7058be8d3fcbe736e993e4.md.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-18</span><a class="blog-slider__title" href="2022/09/18/less/" alt="">less用法</a><div class="blog-slider__text">最近less水平又有提高了，搏一搏</div><a class="blog-slider__button" href="2022/09/18/less/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/09/18/hexo-buttfly-note/" alt=""><img width="48" height="48" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/f6f00b06d2b8f74d17450329d3be5483.md.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-18</span><a class="blog-slider__title" href="2022/09/18/hexo-buttfly-note/" alt="">Hexo+butterfly搭建博客随手记</a><div class="blog-slider__text">想到什么就写什么，大多是过程中的思考和经验（不是教程）</div><a class="blog-slider__button" href="2022/09/18/hexo-buttfly-note/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/09/18/ES-next/" alt=""><img width="48" height="48" src= "https://butterfly.js.org/img/loading.gif" data-lazy-src="https://img.gejiba.com/images/81f26ca2da3fc4f02ed4bfed1371414e.md.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-18</span><a class="blog-slider__title" href="2022/09/18/ES-next/" alt="">ES-next使用说明</a><div class="blog-slider__text">ES-next使用说明</div><a class="blog-slider__button" href="2022/09/18/ES-next/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://unpkg.com/swiper@8/swiper-bundle.min.js"></script><script defer data-pjax src="https://cdn.cbd.int/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://calendar.lovelee.cn/api?jia0213",['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'],'jia0213')
    }
  </script><!-- hexo injector body_end end --></body></html>